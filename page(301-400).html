<html>

    <head>

        <title>Pages</title>

        <link rel="stylesheet" href="html.css">

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

       <link rel="stylesheet" href= "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

       <link rel="stylesheet" media="all and (max-width:480px)" href="html.css">

       

    </head>

    <body>
      <p><b><h6>Format</h6></b></p>
      <p><b><h5>subfield</h5></b></p>
      <img src="1.PNG">
      <p><b>Usage Notes</b></p>
       <p> The subfield name definitions are:</p>
      <p><b>CHANGE</b></p>
       <p> The method specification of the change method</p>
       <p><b>NOTIFY</b></p> 
        A subscription specification list representing notification subscriptions<br>
       <b> PREV_VALUE</b>
        The previous value of the field<br>
        <b>QUERY</b>
        The method specification of the query method<br>
        <b>TIMESTAMP</b>
        The time stamp of the last change to the field<br>
      <b>  VALUE</b>
        The value of the field<br>
      <b>  subs_spec:</b><br>
      <b>  Purpose</b><br>
        A subs_spec is a notification subscription specification which consists of a method<br>
        specification followed by a recipient specification, separated by a comma.<br>
        Format<br>
       <b> subs_spe</b></p>
       <img src="2.PNG">
       <p><b>subs_spec_list:</b>
       <b> Purpose</b>
        A subs_spec_list is a list of subscript specifications.<br>
       <b> Format</b></p>
       <img src="3.PNG">
       <p><b>type:</b></p>
       <hr>
       <p><b>Purpose</b><br>
        A predefined data type keyword.<br>
        <b>Format</b><br>
       <b> type</b></p><br>
       <img src="4.PNG">
       <p><b>Notes:</b><br>
        1. These data types are valid only within SELFDEFINING data:<br>
        APPLICATIONID<br>
        CHARVARADDR<br>
        CLASSIDLIST<br>
        CLASSLINKLIST<br>
        ECBADDRESS<br>
        METHODNAME<br>
        METHODPARAMETERLIST<br>
        OBJECTIDLIST<br>
        OBJECTNAME<br>
        RECIPIENTSPEC<br>
        SHORTNAME<br>
        SUBSCRIBEID<br>
        SUBSCRIPTSPEC<br>
        SUBSCRIPTSPECLIST<br>
        TRANSID<br></p>
        <hr>
        <p>2. For limitations in CLASSID and OBJECTID, see “Using CLASSID and<br>
            OBJECTID Data Types” on page 259.<br>
          <b>  typed_value:</b><br>
          <b>  Purpose</b><br>
            <i>A typed_value</i> is a concatenation of a left parenthesis, a type keyword, a right<br>
            parenthesis, and a value to match the data type of the type keyword.<br>
          <b>  Format</b><br>
           <b> typed_value</b></p><br>
           <img src="5.PNG">
           <p><b>Notes:</b><br>
            1 TIMESTAMP must be exactly 8 bytes.<br>
            2 TRANSID must be exactly 8 bytes.<br>
           <b> Usage Notes</b>
            You can specify null values for some of the data types. See “Null Values for<br>
            RODM Load Function Data Types” on page 259.</p><br>
            <hr>
            
            <p><h3><b>Chapter 11. Writing Applications that Use RODM</h3></b></p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;RODM provides a user application programming interface (user API). This user API<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   allows a properly authorized address space to access the data contained in the<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   RODM address space and data spaces. Through this user API, objects can be<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   created, organized into hierarchies, or deleted. The user API can also be used to<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   query the value of a field associated with an object or to alter the value in that<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   field. The user API can be called from NetView command processors and from<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   applications written in any programming language that meets the parameter<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   passing conventions of RODM. While RODM provides control block mappings in<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   PL/I and C, you can write applications in any programming language that uses<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   the interface described in “Register Conventions” on page 306.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   RODM also provides a method API, which shares many functions with the user<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   API. The method API is described in Chapter 13, “Writing RODM Methods,” on<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   page 343.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   The NetView program supplies a set of general-purpose methods. For a description<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   of these methods, see “Supplied Methods” on page 488.<br></p>
            <hr>
           <p><b><h3>Tasks Best Performed with User Applications</h3></b></p>
           <p>&nbsp;&nbsp;&nbsp;&nbsp;This section describes which tasks are best performed with user applications.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    Use an application program to do the following: 
            <li> Supply status changes of resources to the RODM data cache.</li><br>
            &nbsp;&nbsp;&nbsp;&nbsp;    The RODM data cache is viewed as a model of real-world resources; therefore,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    ensure that resource objects in the data cache are updated as actual resources<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    change status. v Subscribe for notification of data changes.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    Before a user application program can receive notification of RODM data cache<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    changes, a notification subscription to the necessary fields in the relevant objects<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    or classes is required. v Wait for and process data change notifications.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    The user application is responsible for waiting for and processing the<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    notifications from the objects or classes to which it is subscribed.
             <li> Query data for operator view, displays, and queries.</li><br>
            &nbsp;&nbsp;&nbsp;&nbsp;    Application programs that communicate with users through a user interface and<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    require access to data in the RODM data cache and must query that data<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    through RODM.
            <li> Add or delete resources.</li><br>
            &nbsp;&nbsp;&nbsp;&nbsp;    Application programs requiring data cache hierarchy modification can do so by<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    calling RODM to manipulate objects and classes.
             <li>Communicate with NetView applications.</li><br>
            &nbsp;&nbsp;&nbsp;&nbsp;    NetView applications can query and change RODM data through the user API.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;   You can use either RODMView or the MultiSystem Manager Access facility to<br>
            &nbsp;&nbsp;&nbsp;&nbsp;    query and change RODM data.<br></p>
            <hr>
            <p><b><h3>Using the User Application Program Interface</h3></b></p>
            <p>User API calls to RODM must pass the following four parameters to module<br>
                EKGUAPI:
                <li> Access block</li>
                <li>Transaction information block</li>
                <li>Function block</li>
                <li> Response block</li>
                The function block can point to additional parameters, such as entity access<br>
                information blocks and field access information blocks, which identify the target of<br>
                the function.<br>
                Figure 68 shows typical user API invocations, first in C and then in PL/I.<br>
                <img src="6.PNG">
                <p><i>Figure 68. Typical User API Invocation in C and PL/I</i></p>
                The call statement transfers control to the code segment identified as EKGUAPI.<br>
                The user can include EKGUAPI module during the link-edit of the application.<br>
                <b><h3>Register Conventions</h3></b>
                &nbsp; &nbsp; &nbsp;The generated code must follow these conventions.<br>
               <b>Register 1</b><br>
               &nbsp; &nbsp; &nbsp;Points to a four-entry parameter list that contains the addresses of the<br>
               &nbsp; &nbsp; &nbsp;  access_block, transaction_info_block, function_block, and response_block,<br>
               &nbsp; &nbsp; &nbsp;  respectively. These control blocks are shown in Figure 69 on page 309.<br>
              <b>Register 13</b><br>
                 &nbsp; &nbsp; &nbsp;Contains the address for the calling program's 72-byte save area.<br>
               <b>Register 14</b><br>
               &nbsp; &nbsp; &nbsp;   Contains the return address for the calling program.<br>
              <b>  Register 15</b><br>
              &nbsp; &nbsp; &nbsp; Contains the entry address for the EKGUAPI module.<br>
               <b><h3> Usage Notes®</h3></b>
               &nbsp; &nbsp; &nbsp;  Within this programming guide the term null pointer is used. The value of a null<br>
               &nbsp; &nbsp; &nbsp;  pointer is defined as X'00000000'. Using PL/I, this value is provided by the built-in<br>
               &nbsp; &nbsp; &nbsp;   SYSNULL function. Do not use the built-in NULL function; it generates the value<br>
               &nbsp; &nbsp; &nbsp;   X'FF000000'.<br>
               &nbsp; &nbsp; &nbsp;   If the call is made from a high-level language where the parameter list is built by<br>
               &nbsp; &nbsp; &nbsp;   the compiler and a null response_block value cannot be passed, a pointer to a<br>
               &nbsp; &nbsp; &nbsp;   dummy response_block must be specified. The dummy response_block must be in<br></p>
               <hr>
               <p>the correct format and specify a length of at least 8. See “Response Block” on page<br>
                319 for additional information about response blocks.<br>
                User API calls are synchronous. The EKG_ExecuteFunctionList function can specify<br>
                a list of other functions that are to be run. If the list of functions contains two<br>
                adjacent functions that affect the same object, the lock on that object is not released<br>
                during the time interval between the processing of the two functions.<br>
                RODM applications must be running in key 8 at the time EKGUAPI is called. All<br>
                parameter lists, control blocks, and other data areas that are passed to RODM must<br>
                reside in storage that is accessible in key 8.<br>
                <b><h3>Compiling and Link-Editing</h3></b>
                &nbsp; &nbsp; &nbsp;    The application can link-edit the EKGUAPI module during the link-edit step or<br>
                &nbsp; &nbsp; &nbsp;    dynamically load the module during execution.<br>
                &nbsp; &nbsp; &nbsp;   <b><h3>Compiling C Modules that Call EKGUAPI</h3></b>
                &nbsp; &nbsp; &nbsp;    If any RODM control blocks are referenced in the modules, include the<br>
                &nbsp; &nbsp; &nbsp;     EKG3CINC.H file in your source file. This file includes all of the RODM function<br>
                &nbsp; &nbsp; &nbsp;     and response blocks, and the function prototype statements for the RODM entry<br>
                &nbsp; &nbsp; &nbsp;    points EKGUAPI, EKGMAPI, and EKGWAIT. <br>
                If no RODM control blocks are referenced in the modules, but the modules call<br>
                &nbsp; &nbsp; &nbsp;    EKGUAPI or EKGWAIT, include the EKG3CEEP.H file in your source file.<br>
                &nbsp; &nbsp; &nbsp;   Example:<br>
                &nbsp; &nbsp; &nbsp;    #include "EKG3CINC.H"<br>
                &nbsp; &nbsp; &nbsp;    /* or */<br>
                &nbsp; &nbsp; &nbsp;    #include "EKG3CEEP.H"<br>
                &nbsp; &nbsp; &nbsp;    void thisproc (void arg)<br>
                &nbsp; &nbsp; &nbsp;     {<br>
                    &nbsp; &nbsp; &nbsp;    /* code */<br>
                    &nbsp; &nbsp; &nbsp;    }<br>
                    &nbsp; &nbsp; &nbsp;   <b><h3> Compiling PL/I Modules that Call EKGUAPI</h3></b>
                    &nbsp; &nbsp; &nbsp;    If any RODM control blocks are referenced in the modules, include the EKG1IINC<br>
                    &nbsp; &nbsp; &nbsp;    file in your source file. This file includes all of the RODM function and response<br>
                    &nbsp; &nbsp; &nbsp;    blocks, and the function prototype statements for the RODM entry points<br>
                    &nbsp; &nbsp; &nbsp;    EKGUAPI, EKGMAPI, and EKGWAIT. <br>
                    If no RODM control blocks are referenced in the modules but the modules call<br>
                    &nbsp; &nbsp; &nbsp;     EKGUAPI or EKGWAIT, include the EKG1IEEP file in your source file.<br>
                    &nbsp; &nbsp; &nbsp;    Specify the MACRO preprocessor compiler option if you include RODM macros in<br>
                    &nbsp; &nbsp; &nbsp;    your user application, for example, as follows:<br>
                    &nbsp; &nbsp; &nbsp;   *PROCESS MACRO;<br>
                    &nbsp; &nbsp; &nbsp;    thisproc: proc;<br>
                    &nbsp; &nbsp; &nbsp;      %include ekglib(EKG1IINC);<br>
                    &nbsp; &nbsp; &nbsp;     or<br>
                    &nbsp; &nbsp; &nbsp;     %include ekglib(EKG1IEEP);<br>
                    &nbsp; &nbsp; &nbsp;    /* code */<br>
                    &nbsp; &nbsp; &nbsp;    end thisproc;<br></p>
                    <hr>
                    <p><b><h3>&nbsp; &nbsp; &nbsp;Linking Modules that Call EKGUAPI Directly</h3></b>
                        &nbsp; &nbsp; &nbsp;   The INCLUDE SYSLIB(EKGUAPI) link-edit control statement must be specified<br>
                        &nbsp; &nbsp; &nbsp;    before the ENTRY statement in your source file.<br>
                        &nbsp; &nbsp; &nbsp;    The AMODE=31 link-edit option must be specified.<br>
                        &nbsp; &nbsp; &nbsp;   The RMODE=ANY or RMODE=24 link-edit option must be specified.<br>
                        &nbsp; &nbsp; &nbsp;   The following ENTRY CEESTART statement must be specified:<br>
                        &nbsp; &nbsp; &nbsp;   <module code><br>
                            &nbsp; &nbsp; &nbsp;   INCLUDE SYSLIB(EKGUAPI)<br>
                            &nbsp; &nbsp; &nbsp;   ENTRY CEESTART<br>
                            &nbsp; &nbsp; &nbsp;    NAME module_name(R)<br>
                        <b><h3>&nbsp; &nbsp; &nbsp;Linking Modules that Load and then Call EKGUAPI</h3></b>
                        &nbsp; &nbsp; &nbsp;    Because EKGUAPI is a load module, modules that first load and then call<br>
                        &nbsp; &nbsp; &nbsp;    EKGUAPI do not need special link-edit control statements. However, the<br>
                        &nbsp; &nbsp; &nbsp;   EKGUAPI load module must be accessible to the module that loads it (through<br>
                        &nbsp; &nbsp; &nbsp;   STEPLIB, JOBLIB, or z/OS linklist).</p><br>
                        <hr>
                       <p><b><h3> Using Control Blocks</h3></b>
                        &nbsp; &nbsp; &nbsp;All user API calls to RODM pass four parameters as shown in Figure 69 on page<br>
                        &nbsp; &nbsp; &nbsp;309. The figure is an example of the relationships between the user API call and<br>
                        &nbsp; &nbsp; &nbsp;the control blocks for a RODM query function request. The control block<br>
                        &nbsp; &nbsp; &nbsp;relationships are similar for other RODM function requests from the user<br>
                        &nbsp; &nbsp; &nbsp;application.<br>
                        &nbsp; &nbsp; &nbsp;The parameters passed are pointers to the following control blocks:<br>
                        &nbsp; &nbsp; &nbsp;<b>Access Block</b><br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Contains the user information needed to process the user API request.<br>
                        &nbsp; &nbsp; &nbsp;<b>Transaction Information Block</b><br>
                        &nbsp; &nbsp; &nbsp;Contains transaction information and status about the API request.<br>
                        &nbsp; &nbsp; &nbsp;<b>Function Block</b><br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Contains the details of the requested transaction against RODM data. The<br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;content of this control block varies depending on the transaction requested.<br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;For some requested transactions it includes pointers to two information<br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;blocks:<br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Entity Access Information Block<br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Field Access Information Block<br>
                        &nbsp; &nbsp; &nbsp;<b>Response Block</b><br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Contains the output data from the transaction requested. The format and<br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;specific content of the response block depends on the type of transaction<br>
                        &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;requested.<br>
                        &nbsp; &nbsp; &nbsp;In Figure 69 on page 309, the PL/I-like syntax describes the four passed control<br>
                        &nbsp; &nbsp; &nbsp;blocks and the two associated access information blocks. Equivalently organized<br>
                        &nbsp; &nbsp; &nbsp;blocks can be represented in C. The actual order and offset position within the<br>
                        &nbsp; &nbsp; &nbsp;control blocks are specified in the tables referenced within each of the following<br>
                        &nbsp; &nbsp; &nbsp;control block descriptions.</p><br>
                        <hr>
                        <img src="7.PNG">
                        <p><b><h3>Access Block
                            Description</h3></b>
                            &nbsp; &nbsp; &nbsp;The access block contains user information that RODM needs to process user API<br>
                            &nbsp; &nbsp; &nbsp;requests.<br>
                         <b><h3>&nbsp; &nbsp; &nbsp;Function Block Format</b></h3>
                         &nbsp; &nbsp; &nbsp;    Table 25 on page 310 describes the format of the access block. The table headings<br>
                         &nbsp; &nbsp; &nbsp;    have the following meanings:<br>
                         &nbsp; &nbsp; &nbsp;<b>Offset</b>&nbsp; Specifies the offset to the beginning of the parameter in decimal bytes.<br>
                         &nbsp; &nbsp; &nbsp;  <b>Length</b><br>
                         &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;    Specifies the length of the parameter in decimal bytes.<br>
                         &nbsp; &nbsp; &nbsp;  <b> Type</b>&nbsp; &nbsp; Specifies the RODM data type of the parameter. See “Abstract Data Type<br>
                         &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Reference” on page 219 for more information.<br>
                         &nbsp; &nbsp; &nbsp;  <b> Use </b>&nbsp; &nbsp;Specifies whether the parameter is used for data input to a function or for<br>
                         &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;   data output by a function.<br></p>
                         <hr>
                         <img src="8.PNG">
                         <p><b><h4>Function Block Field Descriptions</h4></b></p>
                           <p><b><h6> RODM_name</h6></b></p>
                           <p>&nbsp; &nbsp; &nbsp;The name of the RODM that is to receive this request to connect must be<br>
                            &nbsp; &nbsp; &nbsp; placed by the caller in the RODM_name field. Because the access block is<br>
                            &nbsp; &nbsp; &nbsp; usually reused on successive calls, the RODM_name field is set only once by a<br>
                            &nbsp; &nbsp; &nbsp; user, just before the connection request is issued. This is the name that you<br>
                            &nbsp; &nbsp; &nbsp;  specify when you start RODM. To determine the RODM name, refer to<br>
                            &nbsp; &nbsp; &nbsp;  NetView online help.</p><br>
                           <p><b><h6> Sign_on_token</h6></b></p>
                          <p>&nbsp; &nbsp; &nbsp;  The token that RODM uses to uniquely identify the user. The data structure<br>
                            &nbsp; &nbsp; &nbsp; that RODM sets at completion of the connection is returned in the<br>
                            &nbsp; &nbsp; &nbsp; sign_on_token parameter. <br>
                            &nbsp; &nbsp; &nbsp; The sign_on_token is set by RODM each time a user connects to RODM.</p><br>
                           <p><b><h6> User_appl_ID</h6></b></p>
                           <p>&nbsp; &nbsp; &nbsp;The identifier that the user application program specifies to identify itself. For<br>
                            &nbsp; &nbsp; &nbsp;an APF (authorized program facility) authorized program, the User_appl_ID<br>
                            &nbsp; &nbsp; &nbsp; alone identifies the user to RODM and determines the user's capabilities. For<br>
                            &nbsp; &nbsp; &nbsp; application programs that are not APF authorized, the User_appl_ID is<br>
                            &nbsp; &nbsp; &nbsp; combined with the password or password phrase from the connect function<br>
                            &nbsp; &nbsp; &nbsp; block to identify the user to RODM and determine the user's capabilities. This<br>
                            &nbsp; &nbsp; &nbsp; field is a maximum of 8 bytes with shorter values left-justified in the field and<br>
                            &nbsp; &nbsp; &nbsp; padded on the right with blanks. Valid characters for this string are the same<br>
                            &nbsp; &nbsp; &nbsp;as for object names.<br>
                            <p><b><h5>Examples</h5></b></p>
                            Sample control blocks for PL/I and C are supplied with RODM. Include these<br>
                            control blocks in your programs.</p><br>
                            <img src="9.PNG">
                            <p><b>Usage</b><br>
                                RODM needs a fully initialized access block to successfully complete user API calls<br>
                                that are issued after the Connect request. You must reference or define an access<br>
                                control block with every call to the RODM User Interface (EKGUAPI).</p><br>
                                <hr>
                                <p> &nbsp; &nbsp; &nbsp;Several applications can access the RODM data cache at the same time and trigger<br>
                                    &nbsp; &nbsp; &nbsp;  methods appropriate to each application's function. The sign_on_token field of the<br>
                                    &nbsp; &nbsp; &nbsp; access block is used to identify the user for each transaction.<br>
                                    &nbsp; &nbsp; &nbsp; RODM verifies the authorization level of the user application. Each RODM<br>
                                    &nbsp; &nbsp; &nbsp; function requires a particular authorization level.<br>
                                    &nbsp; &nbsp; &nbsp; The fields in the access block set by the caller are the RODM_name and<br>
                                    &nbsp; &nbsp; &nbsp; User_appl_ID fields. These fields are set once, by the application, just before the<br>
                                    &nbsp; &nbsp; &nbsp; user API is called. The EKG_Connect or EKG_ConnectLong user API fills in a<br>
                                    &nbsp; &nbsp; &nbsp;value for the sign_on_token field. After the access block is established by a connect<br>
                                    &nbsp; &nbsp; &nbsp;request, the application does not modify the information in that block.<br>
                                    &nbsp; &nbsp; &nbsp;   More details about connection to RODM are provided in “Connecting to RODM”<br>
                                    &nbsp; &nbsp; &nbsp; on page 331.<br>
                                    <p><b><h4>Transaction Information Block<br>
                                    Description</h4></b></p>
                                    &nbsp; &nbsp; &nbsp;   The transaction information block contains transaction-status information about<br>
                                    &nbsp; &nbsp; &nbsp;  each API request. The transaction information block is required for every RODM<br>
                                    &nbsp; &nbsp; &nbsp; function request.<br>
                                    <b>Function Block Format</b><br>
                                    &nbsp; &nbsp; &nbsp;  Table 27 describes the format of the transaction information block. The table<br>
                                    &nbsp; &nbsp; &nbsp;  headings have the following meanings:<br>
                                    &nbsp; &nbsp; &nbsp;   <b> Offset</b>&nbsp;  Specifies the offset to the beginning of the parameter, in decimal bytes.<br>
                                    &nbsp; &nbsp; &nbsp;  <b>  Length</b><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;    Specifies the length of the parameter, in decimal bytes.<br>
                                    &nbsp; &nbsp; &nbsp;  <b> Type</b> Specifies the RODM data type of the parameter.<br>
                                    &nbsp; &nbsp; &nbsp; <b> Use</b> Specifies whether the parameter is used for data input to a function or for<br>
                                    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   data output by a function. A dash (—) indicates that the parameter is not<br>
                                    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   used by functions or is reserved.<br>
                                    &nbsp; &nbsp; &nbsp;  <b> Parameter Name</b><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    Specifies the name of the parameter.</p><br>
                                    <img src="10.PNG">
                                    <hr>
                                    <p><h4><b>Function Block Field Descriptions</b></h4></p>
                                       <b> API_version</b><br>
                                       &nbsp; &nbsp; &nbsp;    The API_version field specifies the version of the API that RODM is to use for<br>
                                       &nbsp; &nbsp; &nbsp;    the API request. The valid values for this field are:<br>
                                       &nbsp; &nbsp; &nbsp;    0 RODM is to use the most recent API version<br>
                                       &nbsp; &nbsp; &nbsp;   1 RODM is to use version 1 API<br>
                                       <b> EPL_blk_len</b><br>
                                       &nbsp; &nbsp; &nbsp;    Not used, but retained for compatibility. <br>
                                       <b> Transaction_ID</b><br>
                                       &nbsp; &nbsp; &nbsp;    Every RODM transaction initiated by a user application is assigned a unique<br>
                                       &nbsp; &nbsp; &nbsp;    transaction ID by RODM. Synchronous method transactions that are triggered<br>
                                       &nbsp; &nbsp; &nbsp;    by a user application transaction have the same transaction ID as the user<br>
                                        &nbsp; &nbsp; &nbsp;   application. The transaction_ID field controls the order of this transaction<br>
                                        &nbsp; &nbsp; &nbsp;   relative to all other transactions. The transaction ID is also used in journaling<br>
                                        &nbsp; &nbsp; &nbsp;   all transactions against RODM between checkpoints. These are described in<br>
                                        &nbsp; &nbsp; &nbsp;   detail in the section of this document on Registering for Checkpoint<br>
                                        &nbsp; &nbsp; &nbsp;   Notification. See “Coding Checkpoint Control” on page 386.<br>
                                        <b>Return_code</b><br>
                                        &nbsp; &nbsp; &nbsp;    Return code from RODM. See “RODM Return and Reason Codes” on page 459<br>
                                        &nbsp; &nbsp; &nbsp;    for a list of return codes.<br>
                                       <b> Reason_code</b><br>
                                       &nbsp; &nbsp; &nbsp;   Reason code from RODM. See “RODM Return and Reason Codes” on page 459<br>
                                       &nbsp; &nbsp; &nbsp;   for a list of reason codes.<br>
                                       <b> EPL_info</b>
                                       &nbsp; &nbsp; &nbsp;    Not used, but retained for compatibility.<br>
                                    <b> Lock_level</b><br>
                                    &nbsp; &nbsp; &nbsp;    Not used, but retained for compatibility. <br>
                                        <b>Examples</b><br>
                                        &nbsp; &nbsp; &nbsp;    Sample control blocks for PL/I and C are supplied with RODM. Include these<br>
                                        &nbsp; &nbsp; &nbsp;    control blocks in your programs.<br>
                                        <img src="12.PNG">
                                        <p><b>Usage</b></p>
                                            The return code and reason code fields are used for RODM to communicate with<br>
                                            the user application about the status of the requested function.<br>
                                           <h4><b>Function Block<br>
                                            Description</h4></b>
                                            The details of all transactions against RODM data are specified in function blocks.<br>
                                            A user builds a function block and passes it to RODM to request a desired<br>
                                            transaction.</p>
              <hr>
              <p><b><h4>Function Block Format</h4></b></p>
               <p>The format of each function block is listed in “Function Reference” on page 375.<br>
               <h4>Function Block Field Descriptions</h4>
                A description of each parameter used in the function blocks is listed in “Functionm<br>
                Parameter Descriptions” on page 452.<br>
               <b>Usage</b>
                The first field in every function block contains a 4-byte integer that specifies which<br>
                function is being requested. The format of the remainder of the function block is<br>
                dependent upon the four-byte function ID.<br>
                One common format for a function block includes the specification of a class, an<br>
                object, and a field. Sometimes there are also fields in the function block used to<br>
                specify a subfield in RODM. Sometimes only a class and an object can be specified<br>
                in a function block. Sometimes, only a class can be specified.<br>
               <h3>Entity Access Information Block<br>
                Description</h3>
                The entity access information block (EAIB) contains information used by the API to<br>
                access a class or object. The EAIB is separate from the function block so that it can<br>
                be reused on subsequent API calls. A pointer to the EAIB is stored in the function<br>
                block.<br>
                The access information is available in two different forms:<br>
                 <li>Symbolic names provided by the application. </li>
                 <li>IDs generated by RODM when symbolic names are used to create a class or</li><br>
                     object. This form provides the fastest access to the information.<br>
               <h4>Function Block Format</h4><br>
                Table 29 describes the format of the entity access information block. The table<br>
                headings have the following meanings:<br>
                <b>Offset</b> Specifies the offset to the beginning of the parameter, in decimal bytes.<br>
                <b>Length</b><br>
                &nbsp; &nbsp; &nbsp; Specifies the length of the parameter, in decimal bytes.<br>
               <b>Type </b>Specifies the RODM data type of the parameter.<br>
               <b> Use </b>Specifies whether the parameter is used for data input to a function or for<br>
               &nbsp; &nbsp; &nbsp;  data output by a function. A dash (—) indicates that the parameter is not<br>
               &nbsp; &nbsp; &nbsp;  used by functions or is reserved.<br>
               <b> Parameter Name</b><br>
               &nbsp; &nbsp; &nbsp; Specifies the name of the parameter.</p><br>
               <img src="13.PNG">
               <hr>
               <img src="13.PNG">
               <p><h4>Function Block Field Descriptions</h4>
               <b>Naming_count </b>
                The Naming_count field in the entity access information block specifies which<br>
                data in the block is valid. Valid values are:<br>
              <b> Value Meaning</b>
                0,2 Specifies that the target of the function is either a class or an object and<br>
                that both the object access information and the class access information<br>
                are valid.<br>
                1 Specifies that the target of the function is a class and that only the class<br>
                access information is valid.<br>
                Interpretation of all this information is subject to the rules in “Usage” on page<br>
                315.<br>
              <b> Class_ID</b><br>
                Class identifier.<br>
                <b>Class_name_length</b><br>
                Class name length.<br>
               <b> Class_name_ptr</b><br>
                This is the pointer to the class name. With a variable declared in PL/I as a<br>
                varying length string, for example, CLASS1 CHAR(64) VARYING, the class<br>
                name pointer is specified using the PL/I Pointeradd built-in function. To point<br>
                directly at the character data rather than at the PL/I 2-byte length prefix, code<br>
                class_name_ptr = POINTERADD(ADDR(CLASS1) ,2 )<br>
              <b>  Object_ID</b><br>
                Object identifier.<br>
              <b> Object_name_length</b><br>
                Object name length.<br>
              <b>Object_name_ptr</b><br>
                This is the pointer to the object name. With a variable declared in PL/I as a<br>
                varying length string, for example, OBJECT1 CHAR(255) VARYING, the object<br>
                name pointer is specified using the PL/I Pointeradd built-in function. To point<br>
                directly at the character data rather than at the PL/I 2-byte length prefix, code<br>
                object_name_ptr = POINTERADD(ADDR(OBJECT1) ,2 )<br>
                <b>Examples</b><br>
                Sample control blocks for PL/I and C are supplied with RODM. Include these<br>
                control blocks in your programs.</p><br>
                <hr>
                <img src="15.PNG">
                <p><b>Usage</b>
                    The function_ID in the function block specifies the function block used. The<br>
                    function block specifies whether or not the entity access information block is used<br>
                    for that function.<br>
                    A null length value for a corresponding pointer indicates a null string, regardless<br>
                    of the value of the pointer. Similarly, a null pointer value also indicates a null<br>
                    string, regardless of the value of the corresponding length. A null string is<br>
                    indicated by either a null length or a null pointer.<br>
                     Pointers to names, if used, point to variable-length character strings. The length of<br>
                    the character string is specified as a parameter in the entity access information<br>
                    block, and the pointer in the entity access information block directly points to the<br>
                    first byte of the character data.<br>
                    Identifiers (RODM-generated internal IDs) exist in RODM because they are faster<br>
                    to process than are character string names. Identifiers are always given preference<br>
                    over character string names in resolving which class or object is to be addressed.<br>
                    The following apply: <br>
                    <li>If both the Class_ID and the Class_name_length are not null values in an entity<br>
                    access information block, the Class_ID is used, and the Class_Name_Ptr is<br>
                    ignored. RODM does not check to determine if a Class_ID is consistent with a<br>
                    class name where both are supplied by the caller.</li><br>
                    <li>If both the Object_ID and the Object_name_length are not null and the<br>
                    Naming_count is not 1, the Object_ID is used, and the Object_Name_Ptr is<br>
                    ignored. RODM does not check to determine if a supplied Object_ID is<br>
                    consistent with a supplied object name.</li><br>
                    <li>If the Naming_count is 1, only class information is used by RODM.<br>
                    An object identifier is sufficient to locate an object; it includes the identification of<br>
                    the class that contains the object. When an object identifier is given, RODM ignores<br>
                    all other object and class information.</li><br>
                    If no Object_ID is provided and an object is required in the specification of the<br>
                    target of the intended transaction, an Object_Name must be provided. In that case,<br>
                    either the Class_ID must specify the class of the object, or the Class_Name_Ptr<br>
                    must point to the name of the class. An error results if the specified class has no<br>
                    object with that name.<br>
                    For transactions that address a field of a class, no object is involved. The same<br>
                    format is used for object and class access information blocks. Set the Object_ID and<br>
                    the Object_name_length fields to null values to alert RODM that the target of the<br>
                    transaction is on a class instead of on an object. The target class is the one specified<br>
                    with either a Class_ID or by the Class_Name_Ptr. Alternatively, the user can set the<br>
                    Naming_count field to a value of 1 and limit the scope of information analyzed by<br>
                    RODM.</p><br>
<hr>
Control blocks are designed to be used repeatedly. For improved performance,<br>
reuse control blocks. During the execution of an application that uses RODM,<br>
similar transactions might be repeatedly requested with changes in the targets of<br>
those transactions. The following actions are taken by RODM to simplify repeated<br>
use of an entity access information block. <br>
<li>If the Class_ID field is null when RODM is called, and the Class_Name_Ptr field<br>
is not null, and the requested transaction completes successfully (a return code<br>
less than or equal to 4), RODM fills in the Class_ID field with the class-identifier<br>
of the target class. RODM also fills in the Class_ID when an error prevents the<br>
successful completion of the transaction if the target is accessed before the error<br>
is detected.</li><br>
<li>If the Object_ID field is null when RODM is called, and the Object_Name_Ptr is<br>
not null, and the naming count is not equal to 1 (which specifies that only class<br>
information is used), and the requested transaction completes successfully (a<br>
return code less than or equal to 4), RODM fills in the Object_ID field with the<br>
Object-identifier of the target Object. RODM also fills in the Object_ID when an<br>
error prevents the successful completion of the transaction if the target is<br>
accessed before the error is detected.</li><br>
If names are used to specify the targets in a transaction request and the request is<br>
then repeated, reusing the same entity access information block, the identifier fields<br>
are already filled in from the first transaction. The second transaction, therefore,<br>
runs more quickly. <br>
This increase in performance of a second transaction occurs to a lesser degree in<br>
each of several circumstances where the second transaction is similar to but not the<br>
same as the first transaction. For example, a performance increase of a lesser<br>
degree on a second transaction is obtained when:<br>
 <li>The second transaction specifies the same field as the first transaction, regardless<br>
of the class and object fields.</li><br>
 <li>The first and second transactions have the same object as a target, but the first<br>
transaction uses a character string name to specify the object.</li><br>
 <li>The second transaction specifies the same class as the first transaction (in the<br>
class fields), but each transaction specifies a different object using a character<br>
string name. When entity access information blocks are repeatedly used in this<br>
way, the ObjectID must be set to null after each use of that block. Otherwise, on<br>
reuse, the rule that identifiers are given preference over character string names<br>
applies, and the second transaction is routed to the same target object, as that of<br>
the first transaction.</li><br>
When a function block is reused and the Class_name or Object_name field (or<br>
pointer) is updated, the corresponding identifier fields (Class_ID, Object_ID) must<br>
be reset to null. This is necessary because the character string name has<br>
significance only if the identifier field is set to 0.<br>
<h4>Field Access Information Block<br>
Description</h4>
The field access information block (FAIB) contains information used by the API to<br>
access a field. The FAIB is separate from the function block so that it can be reused<br>
on subsequent API calls. A pointer to the FAIB is stored in the function block.<br>
The access information is available in two different forms:<br>
 <li> Symbolic names provided by the application.</li><br>
 <hr>
 <p><li>IDs generated by RODM when symbolic names are used to create a field. This<br>
    form provides the fastest access to the information.</li></p><br>
    <p><b><h4>Function Block Format</h4></b></p>
    <p>
        Table 31 describes the format of the field access information block. The table<br>
        headings have the following meanings:<br>
        <b>Offset </b>Specifies the offset to the beginning of the parameter, in decimal bytes.<br>
       <b> Length</b><br>
        Specifies the length of the parameter, in decimal bytes.<br>
       <b> Type</b> Specifies the RODM data type of the parameter.<br>
       <b>Use</b> Specifies whether the parameter is used for data input to a function or for<br>
        data output by a function. A dash (—) indicates that the parameter is not<br>
        used by functions or is reserved.<br>
       <b> Parameter Name</b><br>
        Specifies the name of the parameter. <br>
      <i>Table 31. RODM Field Access Information Block</i></p><br>
<img src="16.PNG">
<p><h4>Function Block Field Descriptions</h4><br>
   <b>Naming_count</b><br>
    The naming_count field in the field_access_info block specifies if the field<br>
    access information is valid. The valid values are:<br>
   <b>Value Meaning</b><br>
    0 The information is valid<br>
    1 Reserved<br>
    Always set Naming_count to 0 (zero).<br>
   <b>Field_ID</b><br>
    Field identifier. Field_name_length<br>
   <b>Field name length.</b><br>
   <b> Field_name_ptr</b><br>
    This is the pointer to the field name.<br>
   <b>Examples</b><br>
    Sample control blocks for PL/I and C are supplied with RODM. Include these<br>
    control blocks in your programs.</p><br>
    <hr>
    <p><i>Table 32. Sample Names for Field Access Information Block </i></p><br>
    <img src="17.PNG">
    <p><b>Usage</b><br>
        The function_ID in the function block specifies the function block used. The<br>
        function block specifies whether the field access information block is used for that<br>
        function.<br>

        A null length value for a corresponding pointer indicates a null string, regardless<br>
        of the value of the pointer. Similarly, a null pointer value also indicates a null<br>
        string, regardless of the value of the corresponding length. A null string is<br>
        indicated by either a null length or a null pointer. <br>

        Pointers to names, if used,point to variable-length character strings. The length of<br>
        the character string is specified as a parameter in the field access information block<br>
        along with the pointer that points directly to the first byte of the character data.<br>

        Identifiers (RODM-generated internal IDs) exist in RODM because they are faster<br>
        to process than are character string names. Identifiers are always given preference<br>
        over character string names in resolving which field is to be addressed. If both the<br>
        Field_ID and the Field_name_length are not null in a field access information<br>
        block, the Field_ID is used, and the Field_Name_Ptr is ignored. RODM does not<br>
        check that a supplied Field_ID is consistent with a supplied field name.<br>

        If a field is the target of the desired transaction, the specification of a field must be<br>
        provided by a Field_ID or Field field that is not null. The specified field is<br>
        associated with the entity (object or class) specified in the corresponding entity<br>
        access information block.<br>

        If names are used to specify the targets in a transaction request and the request is<br>
        then repeated, reusing the same entity access information block, the identifier fields<br>
        are already filled in from the first transaction. The second transaction, therefore,<br>
        runs more quickly. <br>

        Control blocks are designed to be used repeatedly. For improved performance,<br>
        reuse control blocks. During the execution of an application that uses RODM,<br>
        similar transactions might be repeatedly requested with changes in the targets of<br>
        those transactions. RODM takes the following action to simplify repeated use of a<br>
        field access information block:<br>
        <li> If the Field_ID field is null when RODM is called, and the Field_name_Ptr is not<br>
        null, and the target of the transaction requires a field, and the requested<br>
        transaction completes successfully, RODM fills in the Field_ID field with the<br>
        Field-identifier of the target field.</li><br>
        <li>RODM also fills in the Field_ID when an error prevents the successful<br>
        completion of the transaction if the target is accessed before the error is detected.</li><br>

        When a function block is reused and the Class_name or Object_name field (or<br>
        pointer) is updated, the corresponding identifier fields (Class_ID, Object_ID) must<br>
        be reset to null. This is necessary because the character string name has<br>
        significance only if the identifier field is set to 0.</p>
        <hr>
        <p><h4>Response Block<br>
            Description</h4>
            The output from RODM query requests, query methods, named methods, and<br>
            object-independent methods is returned in response blocks. The format of the<br>
            response block and the data that the response block contains are dependent on the<br>
            kind of transaction that generated the response.<br>
           <h4>Function Block Format</h4>
            The format of each response block is listed with its associated function. Table 33<br>
            contains a page reference to each response block format by function.<br>
            <i>Table 33. Functions with Response Blocks</i><br>
            <img src="18.PNG">
            <p><h4>Function Block Field Descriptions</h4>
                A description of each parameter used in the response blocks is listed in “Function<br>
                Parameter Descriptions” on page 452.<br>
                <b>Usage</b><br>
                All response blocks have the same basic format:<br>
                 <li> A Response_block_length field set by the method or application indicates the<br>
                length in bytes of the response block that is supplied.</li><br>
                 <li>A Response_block_used field set by RODM indicates the amount of storage used<br>
                in the response block or the amount needed if the block is too small.</li><br>
                <li>A block of storage whose format and contents depend on the transaction type<br>
                but that typically contains:<br>
                – A Data_type field providing the data type ID of the returned data<br>
                – The data returned by the function or by a method triggered by the function</p><br>
                <hr>
                <p>If the response block provided by the caller is too small to hold a complete<br>
                    response, one of the following happens:<br>
                    <li>If the supplied response block has fewer than 8 bytes, the transaction is<br>
                    immediately ended with an error return code.</li><br>
                    <li>If the supplied response block has 8 or more bytes, the transaction is run by<br>
                    RODM.</li><br>
                    <li>The data type and lengths of the returned values and the volume of the output<br>
                    that is generated determine the total number of bytes needed in a response<br>
                    block.</li><br>
                    <li>If there is insufficient room in the response block for the normal return of<br>
                    information after RODM has completed the transaction, RODM sets the<br>
                    Response_Block_Used field of the response block to show the total size of the<br>
                    generated response. RODM stores that portion of the data in the response block<br>
                    equal to the number of bytes specified in the Response_Block_Length field.</li><br>
                    RODM can take one of two actions depending on the setting of the<br>
                    EKG_RBOverflowAction field in the user object:<br>
                    – If that field specifies discard, any overflow data is lost.<br>
                    – If that field specifies to save overflow information, RODM saves the response<br>
                    block overflow data for the user to retrieve on a later call.<br>
                    See “EKG_QueryResponseBlockOverflow - Query for Response Block Overflow”<br>
                    on page 430.<br>
                    The overflow data is identified by the Transaction ID in the transaction<br>
                    information block of the transaction that caused the overflow. The Transaction<br>
                    ID must be specified in the Correlation_ID parameter of the<br>
                    EKG_QueryResponseBlockOverflow function to retrieve the data that did not fit<br>
                    into the original response block. The return and reason codes that are passed to<br>
                    RODM in the function block are set to show the error (response block is too<br>
                    small).<br>
                   <b> Note:</b> With the exception of the EKG_QueryResponseBlockOverflow function<br>
                    and the EKG_Disconnect function, additional transactions associated with the<br>
                    same access block as this transaction are rejected by RODM until the response<br>
                    block overflow data is retrieved by the user.<br>
                    <li>If the transaction causing a response block overflow is run from a list of<br>
                    transactions, remaining transactions in the list are run with all results going into<br>
                    the overflow block for later retrieval. </li><br>
                    <li>All overflow data is placed into an overflow buffer. It is the responsibility of the<br>
                    application to concatenate the data in the response block and this overflow data.<br>
                    Following the response_block_used field, the remainder of the block depends on<br>
                    transaction type, data types, and lengths of lists of data.</li><br>
                    When named and object-independent methods are triggered by transactions<br>
                    against RODM, those methods can generate SelfDefining data strings (variable<br>
                    length strings of type SelfDefining) that return to the task running the transaction<br>
                    through the response block. When named and object-independent methods are<br>
                    triggered, the variable portion of the response block is dedicated to delivering<br>
                    these strings to the calling task.<br>
                    If a named or object-independent method causes an overflow in the response<br>
                    block, the method itself receives a return code and reason code for the overflow. <br>
                    However, the method might not pass this return code and reason code back to the<br>
                    program that triggered the method. Always compare the Response_block_length</p><br>
<hr>
<p>parameter with the Response_block_used parameter returned in the response block<br>
    if a named or object-independent method is triggered. If the value of the<br>
    Response_block_used parameter is larger than the value of the<br>
    Response_block_length parameter, an overflow occurred.<br>
    If multiple transactions are running simultaneously on a single user application ID,<br>
    any or all of them can cause a response block overflow. After an overflow occurs,<br>
    no further user API functions are enabled from EKGUAPI (with the exception of<br>
    the EKG_Disconnect function) until the EKG_QueryResponseBlockOverflow<br>
    function is called.<br>
    All overflow response blocks must be retrieved by the<br>
    EKG_QueryResponseBlockOverflow function before any other user API request<br>
    (with the exception of the EKG_Disconnect function) is enabled from EKGUAPI.<br>
    Each call to the EKG_QueryResponseBlockOverflow function must specify a<br>
    correlation ID, which is the transaction ID of the transaction that caused the<br>
    response block overflow. The correlation ID allows the correct overflow response<br>
    block to be returned.<br>
    Additional details on various kinds of response blocks are provided with many of<br>
    the descriptions of individual RODM functions.</p><br>
    <hr>
    <p><h3><b>Error Conditions in Transactions</b></h3></p>
    <p>If an error condition occurs during the execution of a transaction, RODM issues a<br>
        return code and reason code in the transaction information block. Errors can also<br>
        be recorded in the RODM log, depending on the values of LOG_LEVEL and<br>
        MLOG_LEVEL that are set in the customization file. Unless a method abends, the<br>
        decision to continue execution is left to the method.<br>
        Methods can issue return codes to RODM using the EKG_SetReturnCode function.<br>
        See “EKG_SetReturnCode - Set Return and Reason Codes” on page 438. The error<br>
        can be recorded in the RODM log, and the return and reason code in the call to<br>
        RODM are set to show that the transaction did not complete successfully.<br>
         The return code and reason code issued to methods and user applications are<br>
        determined by RODM as follows:<br>
         <li>The initial return code and reason code for all user API and method API<br>
        transactions are set to 0.</li><br>
         <li>The return code and reason code returned to the user application are determined<br>
        by a synchronous method if one is triggered during the processing of the user<br>
        API request. If a synchronous method does not set the return code, it is set by<br>
        RODM if RODM detects an error during the execution of the user API<br>
        transaction.</li> <br>
        <li>A method can set the return code and reason code that are returned to the caller.<br> 
        The current return and reason codes for a method are initially set to 0. The<br>
        method can change the return and reason codes using the EKG_SetReturnCode<br>
        function. The current return and reason codes are returned to the method that<br>
        triggered this method or to RODM, if RODM triggered this method.</li><br>
        If the method sets a new return code and reason code using the<br>
        EKG_SetReturnCode function, RODM determines the return code and reason<br>
        code that are returned to the caller as follows:<br>
        – If the new return code is greater than the current return code, the new return<br>
        code and reason code replace the current return and reason code for the<br>
        method.</p><br>
        <hr>
        <p>– If the new return code is less than or equal to the current return code, the<br>
            current return and reason code for the method are not changed.<br>
            <li>If the return code and reason code set by a method are returned to the method<br>
            that called it, the calling method's return code and reason code are determined<br>
            exactly as was the called method's.</li><br>
            In addition to issuing return and reason codes, RODM can also write log records<br>
            that provide additional diagnostic information about errors. Transactions that pass<br>
            through the user API are each given a unique Transaction_ID, which RODM<br>
            returns to the caller in the access block. If errors occur in methods or elsewhere in<br>
            a transaction, the Transaction_ID is written in the RODM log record for the error. <br>
            Transactions that pass through the method API are each given the Transaction_ID<br>
            of the parent transaction that was submitted across the method API.<br>
            <li>If a method calls the EKG_SetReturnCode function and the return code and<br>
            reason code are changed, RODM writes a type-3 log record (for object-specific<br>
            methods) or a type-4 log record (for object-independent methods) only if the<br>
            following are true:</li><br>
            – If the method is a synchronous method, the return code must be greater than<br>
            the value of the EKG_LogLevel field in the application program's EKG_User<br>
            object, and logging must be enabled. For information about the<br>
            EKG_LogLevel field, see “EKG_User Class” on page 197.<br>
            – If the method is asynchronous, the return code must be greater than the<br>
            LOG_LEVEL parameter in the RODM customization file. Refer to the IBM<br>
            Tivoli NetView for z/OS Administration Reference for more information about the<br>
            RODM customization file. <br>
            <li>The final return code and reason code returned from the level-1 method (that is,<br>
            the first asynchronous method that is triggered by a</li><br>
            EKG_MessageTriggeredAction function) determines the following:<br>
            – If the final return code is greater than or equal to the value in the<br>
            EKG_LogLevel field of the user object that represents the application program<br>
            that triggered the asynchronous method, a log record is written.<br>
            <li>For user application programs that call EKGUAPI:</li><br>
            – If the final return code is greater than or equal to the value in the<br>
            EKG_LogLevel field of the application program's object, RODM writes a<br>
            type-2 log record to the log.<br>
            The following example shows return and reason code propagation:<br>
            1. User application program UA1 calls EKGUAPI to query a field.<br>
            2. Query method QM1 is triggered because the queried field has a query method<br>
            subfield. The initial return code and reason code for QM1 are both 0.<br>
            3. QM1 triggers a named method, NM1, to perform some processing on the target<br>
            object. The initial return code and reason code for NM1 are both 0.<br>
            4. NM1 sets the return code and reason code, using the EKG_SetReturnCode<br>
            function, to 4 and 2000, respectively. <br>
            5. QM1 receives return code and reason code 4 and 2000 from the named method<br>
            but does not want to return these return and reason codes to the user<br>
            application program. Instead, it sets the return code and reason code to 0 and<br>
            3000, respectively, using the EKG_SetReturnCode function. Had QM1 not set<br>
            the return code and reason code with the EKG_SetReturnCode function, RODM<br>
            returns the return and reason codes of 0 to the user application program.<br>
            6. The user application program receives the return and reason codes of 0 and<br>
            3000<br></p>
            <hr>
            <p>Method writers must be aware of the implications of issuing return and reason<br>
                codes from methods. An application might interpret a return and reason code<br>
                returned by the method as being related to the success or failure of the function,<br>
                when it might only relate to the success or failure of the method. For example, a<br>
                notification subscription is assigned to a field that is successfully changed by the<br>
                EKG_ChangeField function, but the notification method fails and sets a return and<br>
                reason code. In this case, the application might interpret the return and reason<br>
                code as a failure of the EKG_ChangeField function and not a failure of the<br>
                notification method.<br></p>
                <hr>
                <p><h3><b>RODM Notification Process</b></h3></p>
                <p>The RODM notification process enables your user application to be notified when<br>
                    a specified field in RODM changes value. You can use the notification process to<br>
                    automate any process that needs to take place when the value of a field changes.<br>
                    For example, you can automate the recovery of certain network resources when<br>
                    they go down.<br>
                    The RODM notification process can also be used to notify user applications of:<br>
                    <li>Asynchronous errors and checkpoints. “Asynchronous Error Notification” on<br>
                    page 329 describes notification for errors and checkpointing. User applications<br>
                    must set up any required notifications as soon as possible after connecting to<br>
                    RODM.</li>
                    <li>Deleted objects. “Object Deletion Notification” on page 330 describes notification<br>
                    for deleted objects. Instead of installing your own notification methods, your<br>
                    applications use the EKG_AddObjDelSubs function (described on page<br>
                    “EKG_AddObjDelSubs - Add Object Deletion Subscription” on page 379) to<br>
                    subscribe to notification of deleted objects.</li><br>
                    This section describes the RODM notification process, using an example of an<br>
                    automated recovery application. For this example, assume that you have resources<br>
                    named NETRES1, NETRES2, NETRES3, and so on, represented by objects in the<br>
                    RODM data cache. A field of the object named DisplayStatus represents the status<br>
                    of the resource; the value of this field is maintained by another application.<br>
                    Assume also that you have written a user application named RECOVER that can<br>
                    recover one of these resources when it goes down. Set up RODM so that your<br>
                    RECOVER application is notified each time a resource goes down.<br>
                    The RODM notification process has four overall steps:<br>
                    1. Setup<br>
                    2. Wait<br>
                    3. Notification<br>
                    4. Clean up<br>
                    Each overall step is described using the RECOVER example. Some steps can be<br>
                    done in different ways; this example follows the simplest way and describes the<br>
                    other ways as well.<br>
                    The RODM notification process has five elements: v Notification queue<br>
                    <li> Notification method</li><br>
                    <li>Notify subfield</li><br>
                    <li>Event control block (ECB)</li><br>
                    <li>User application</li></p><br>
                    <hr>
                    <p><h3><b>Setup</b></h3></p>
                    <p>The first step in the RODM notification process is setup. Setup includes:<br>
                        <li>Connecting the user application to RODM</li><br>
                        <li>Creating the notify subfield</li><br>
                        <li>Installing the notification method</li><br>
                        <li>Creating the notification queue</li><br>
                        <li>Subscribing to the field</li><br>
                        This example assumes that RODM is running and the objects and application that<br>
                        maintains them are defined. You can complete the setup steps for each field on<br>
                        each object for which you want to be notified, or you can set up notification at the<br>
                        class level. If you set up notification at the class level, the notification process is<br>
                        defined for every object of that class.<br>
                        1. The first step in working with RODM is connecting to RODM. The RECOVER<br>
                        application connects to RODM using the EKG_Connect or EKG_ConnectLong<br>
                        function. RODM creates an object of the EKG_User class that represents the<br>
                        RECOVER application.<br>
                        2. If the DisplayStatus field does not have a notify subfield, the RECOVER<br>
                        application creates one using the EKG_CreateSubfield function. The subfield is<br>
                        created on the same class as the DisplayStatus field.<br>
                        3. Methods must be installed before they can be used. You install a method by<br>
                        placing it in the specified library for RODM and by creating an object of the<br>
                        EKG_Method class that represents the method. “Installing and Freeing<br>
                        Methods” on page 360 describes how to install a method.<br>
                        In this example, one of the notification methods supplied with RODM is being<br>
                        used. The EKGNTHD notification method is triggered when the value of the<br>
                        field falls outside the specified thresholds. The thresholds are passed to<br>
                        EKGNTHD in the Long_lived_parm that is specified on the<br>
                        EKG_AddNotifySubscription function.<br>
                        The EKGNTHD notification method is described in “RODM Notification<br>
                        Methods” on page 489. If the methods supplied with the NetView program do<br>
                        not meet your needs, you can write your own notification method.<br>
                        4. Create a notification queue and its associated event control block (ECB). You<br>
                        need only one notification queue for all objects that are to notify your user<br>
                        application RECOVER. A notification queue is associated with a single user<br>
                        application, but a user application can have many notification queues. The<br>
                        notification queue is an object of the EKG_NotificationQueue class.<br>
                        a. RECOVER creates an object of the EKG_NotificationQueue class using the<br>
                        EKG_CreateObject function. Notification queue names must be unique<br>
                        within a user application. For this example, specify the queue name<br>
                        RECOVQ as the object name in the entity access block of this transaction.<br>
                        RODM concatenates the User_appl_ID of the user application with the<br>
                        queue name specified to create the MyName field of the<br>
                        EKG_NotificationQueue object; in this example, MyName is set to<br>
                        RECOVER.RECOVQ. RODM links the EKG_UsedBy field of the<br>
                        EKG_NotificationQueue object to the EKG_Uses_Q field of the EKG_User<br>
                        object that represents the user application.<br>
                        b. Set the value of the ECB to 0 (zero).<br>
                        c. Set the EKG_ECBAddress field to the address of the ECB you use for this<br>
                        queue. RECOVER uses the EKG_ChangeField function to set the value of<br>
                        this field. The ECB is created in the address space of the user application.<br>
                        Many notification queues can use the same ECB</p>
                        <hr>
                        <p>d. Set the EKG_Status field of the notification queue object you created in Step<br>
                            4a on page 324 to 1 (active). RECOVER uses the EKG_ChangeField function<br>
                            to set the value of this field.<br>
                            You do not have to associate an ECB with a notification queue. Your<br>
                            application can simply query the notification queue from time to time to see if<br>
                            any notifications have been added. However, this is not as useful as the<br>
                            asynchronous notification provided by the ECB.<br>
                            5. The last step in setup is to subscribe to the field for each object. The RECOVER<br>
                            application issues the EKG_AddNotifySubscription function. This function puts<br>
                            the notification method name EKGNTHD, the method parameters, the<br>
                            notification queue name RECOVQ, and the user application ID of RECOVER in<br>
                            the notify subfield. Specify the parameters of this function call as follows:<br>
                          <b>Entity_access_info_ptr</b><br>
                            A pointer to the entity access block that specifies the class and object<br>
                            for which you are creating the notification subscription.<br>
                        <b>Field_access_info_ptr</b><br>
                            A pointer to the field access block that specifies the DisplayStatus field.<br>
                          <b> User_appl_ID</b><br>
                            Set this to the null value. RODM fills in the value that corresponds to<br>
                            the RECOVER application that is issuing this function call.<br>
                          <b> Notification_queue</b><br>
                            Specify the name of the notification queue you created in Step 4 on<br>
                            page 324. For this example, enter the name as RECOVQ, not as<br>
                            RECOVER.RECOVQ. The User_appl_ID part of the name is supplied<br>
                            by RODM.<br>
                          <b>User_word</b><br>
                            You can leave this optional field blank.<br>
                           <b>Notify_method</b><br>
                            Specify the object ID of the object of the EKG_Method class that<br>
                            represents the notification method EKGNTHD. If this is an installed<br>
                            method, this is the value that was returned in the Object_ID field of the<br>
                            entity access block when you created the object for EKGNTHD in Step<br>
                            3 on page 324. If this is a pre-installed method, the object ID is<br>
                            obtained by querying the MyName field of the method.<br>
                            Long_lived_parm<br>
                            Specify the parameters that are to be passed to EKGNTHD when it is<br>
                            triggered. This is where you specify the thresholds that cause this<br>
                            method to be triggered. These parameters are described in “RODM<br>
                            Notification Methods” on page 489.<br>
                            Repeat Step 5 once for each field you subscribe to. The setup for the notification<br>
                            process is complete when the EKG_AddNotifySubscription function has run<br>
                            successfully for each object.<br>
                            Although this example describes notifying one user application when a field<br>
                            changes, any number of applications can be notified. The notify subfield can<br>
                            contain a list of notification subscriptions. Repeat the entire notification process for<br>
                            each user application that is to be notified.<br>
                            Instead of creating a notification subscription for each object, you can create a<br>
                            notification subscription for a class. RODM triggers a notification method defined<br>
                            for a field of a class when that field is changed on any object of the class. The<br></p>
                            <hr>
                            <p>notification method needs to use the Where Am I (2007) function to identify the<br>
                                particular object that caused the method to be triggered.<br>
                                <b>Wait</b>
                                After you have set up the notification process, your application suspends<br>
                                processing until RODM notifies it of a change. Calling EKGWAIT enables your<br>
                                application to wait until a specified ECB or any ECB in a list of ECBs is posted by<br>
                                RODM.<br>
                                EKGWAIT is an interface module that provides the WAIT facilities. Your<br>
                                application calls EKGWAIT with a parameter list containing ECB information.<br>
                                For this example, RECOVER issues a call to EKGWAIT specifying an ECB. When<br>
                                the ECB is posted, EKGWAIT returns control to RECOVER. RECOVER then<br>
                                processes the notification.<br>
                                <b>Calling EKGWAIT</b>
                                RODM supplies sample code that shows how to call EKGWAIT. The PL/I sample<br>
                                is EKG5WAIT and the C sample is EKG6WAIT. Only user applications can use EKGWAIT.<br>
                                 The format of the call to EKGWAIT is<br>
                                as follows:<br>
                                EKGWAIT(Num_ECBs, ECB_Array, Return_code, Reason_code)<br>
                                The following is an explanation of each parameter in the list of parameters<br>
                                specified in a call to the EKGWAIT interface module. This parameter list is also<br>
                                used by EKGWAIT to pass information back to the user application when<br>
                                EKGWAIT returns control.<br>
                               <b>Parameter Name</b><br>
                               <b> Description</b><br>
                               <b>Num_ECBs (In)</b><br>
                                A 2-byte Smallint which specifies the number of ECBs in the event list.<br>
                              <b>ECB_Array (In)</b><br>
                                An array of Pointers where each pointer contains the address of an ECB.<br>
                               <b> Return_code (Out)</b><br>
                                A 4-byte Integer containing the return code.<br>
                              <b>Reason_code (Out)</b><br>
                                A 4-byte Integer containing the reason code. If Return_code is 0, then this<br>
                                field contains the index into ECB_Array for which the ECB was posted.<br>
                               <h4>PL/I Coding Example</h4><br>
                                Figure 70 on page 327 is an example for calling EKGWAIT from a PL/I user<br>
                                application:</p><br>
                                <hr>
                                <img src="19.PNG">
                                <p><h4>C Coding Example</h4></p><br>
                                <img src="20.PNG">
                                <hr>
                                <p><h4>EKGWAIT Usage Notes</h4>
                                    The purpose of the ECB_Array is to contain the ECB addresses being set to the<br>
                                    EKG_ECBAddress fields in the EKG_NotificationQueue objects. However, always<br>
                                    include in the ECB_Array the Stop_ECB identified to RODM at connect time. This<br>
                                    can prevent a user from waiting indefinitely, if RODM is stopped.<br>
                                    On a successful return, where Return_code equals 0, the Reason_code is set to an<br>
                                    integer value indicating the index (1 to N) within the ECB_Array of the ECB that<br>
                                    was posted. Clear the ECB being posted immediately after a successful return from<br>
                                    this function call.<br>
                                    An ECB address of 0 passed to this function call causes an immediate return with<br>
                                    a warning return code. But, an ECB address that is not valid can cause an abend or<br>
                                    an indefinite wait.<br>
                                    <h4>Notification</h4><br>
                                    When the field to which your application has subscribed changes value, its<br>
                                    notification method is triggered. In this example, if the DisplayStatus field of object<br>
                                    NETRES3 changes, RODM triggers notification method EKGNTHD. EKGNTHD<br>
                                    then compares the new value of DisplayStatus to the thresholds you specified in<br>
                                    the Long_lived_parm parameter of the EKG_AddNotifySubscription function.<br>
                                    If the new value exceeds the specified thresholds, EKGNTHD places a notification<br>
                                    block on notification queue RECOVQ and RODM posts the ECB for the RECOVER<br>
                                    application. Notification methods use the EKG_SendNotification function to place<br>
                                    the notification block on the queue. When the ECB is posted, EKGWAIT returns<br>
                                    control to RECOVER.<br>
                                    RODM posts the ECB for a notification queue when all of the following conditions<br>
                                    are met: v The notification queue exists. <br>
                                    <li>A notification block is added to a previously empty queue.</li><br>
                                    <li>The ECB pointer for the queue points to a valid ECB.</li><br>
                                    After RODM posts an ECB for a particular notification queue, RODM does not<br>
                                    post the ECB for that queue again until the queue has been completely drained<br>
                                    and a new block added or until the EKG_ECBAddress field in the notification<br>
                                    queue object is changed.<br>
                                    If you reconnect to RODM and notification subscriptions and notification queue<br>
                                    objects for your user application still exist, the ECB cannot be posted. You must<br>
                                    reset the EKG_ECBAddress field in each notification queue object to a current ECB<br>
                                    address to enable RODM to post the ECBs.<br>
                                    The remaining processing is done by your application.<br>
                                    1. The user application clears the ECB by setting it equal to 0. This enables RODM<br>
                                    to post additional notifications.<br>
                                    2. The application gets the notification blocks from the notification queue using<br>
                                    the EKG_QueryNotifyQueue function. The notification block contains a<br>
                                    Notification_block_type field that indicates the type of event that caused the<br>
                                    notification.<br>
                                    One block is removed for each function call. The response block for this<br>
                                    function indicates the number of notification blocks on the queue in the<br>
                                    Notification_queue_count parameter. The application processes each block on</p><br>
                                    <hr>
                                    <p>the notification queue. The EKG_QueryNotifyQueue function must be issued<br>
                                        from the address space that the user application connected from.<br>
                                        In our example, RECOVER calls the EKG_QueryNotifyQueue function once,<br>
                                        specifying the notification queue name RECOVQ.<br>
                                        3. The application uses the notification block information returned in the response<br>
                                        block to initiate its processing. In our example, RECOVER uses the Object_ID<br>
                                        parameter to identify the resource that changed its DisplayStatus. RECOVER<br>
                                        can use the EKG_QueryField function to get the new DisplayStatus value from<br>
                                        the RODM data cache. RECOVER then issues the appropriate commands to<br>
                                        reactivate the failing resource NETRES3.<br>
                                        4. When it finishes processing the notification queue, the user application calls<br>
                                        EKGWAIT to wait until the next notification takes place.<br>
                                      <h4> Clean Up</h4><br>
                                        Notification processing uses system resources including memory and processor<br>
                                        cycles. When a notification is no longer needed for an object, delete the<br>
                                        notification.<br>
                                        You can delete a notification in either of the following ways: <br>
                                        <li>Delete the notification queue.</li><br>
                                        <li> Delete the notification subscription.</li><br>
                                        If you want to delete all notification subscriptions that use a notification queue,<br>
                                        delete the object of the EKG_NotificationQueue class that represents the<br>
                                        notification queue. Use the EKG_DeleteObject function. RODM deletes the<br>
                                        notification queue and all notification subscriptions that specify that queue. RODM<br>
                                        also deletes any notification blocks that are still on the notification queue.<br>
                                        If you have more than one notification subscription that uses a notification queue,<br>
                                        and you do not want to delete all of the subscriptions, use the<br>
                                        EKG_DeleteNotifySubscription function for each subscription you want to delete.<br>
                                        In this example, you want to shut down NETRES2 for maintenance. To prevent<br>
                                        RECOVER from trying to restart NETRES2, issue the<br>
                                        EKG_DeleteNotifySubscription function and specify NETRES2 with the<br>
                                        Entity_access_info_ptr parameter. The other notification subscriptions are not<br>
                                        affected.<br>
                                        RODM deletes the links between the EKG_User object and the<br>
                                        EKG_NotificationQueue object when you delete a notification queue. When a user<br>
                                        application disconnects from RODM or ends without disconnecting, RODM can<br>
                                        delete the notification queues and subscriptions associated with the user<br>
                                        application. The EKG_StopMode field in the EKG_User object that represents the<br>
                                        object specifies what action RODM takes. See “EKG_User Class” on page 197 for<br>
                                        information about the EKG_StopMode field.<br>
                                        <hr>
                                       <h4> Asynchronous Error Notification</h4><br>
                                        Your user applications can be notified about asynchronous errors and checkpoints<br>
                                        by subscribing to fields in RODM system-defined objects. Subscribe to the<br>
                                        EKG_LastAsyncError field in the EKG_System object to be notified about<br>
                                        asynchronous errors that occur during the execution of asynchronous API requests,<br>
                                        asynchronous methods, or RODM internal processing. Subscribe to the<br>
                                        EKG_LastAsyncError field in the EKG_User object for a user application to receive<br>
                                        notifications only about errors in transactions initiated by that user application.</p><br>
                                        <hr>
                                        <p>The EKGNOTF method that is supplied with the NetView program can be used for<br>
                                            these notification subscriptions. See “RODM Notification Methods” on page 489 for<br>
                                            a description of this method. The log record is assigned to the<br>
                                            EKG_LastAsyncError field. This log record information is placed in the user_data<br>
                                            field of notification queue blocks created because of a subscription to the<br>
                                            EKG_LastAsyncError field. User application programs can obtain this information<br>
                                            by calling the EKG_QueryNotifyQueue function.<br>
                                            When an error occurs, the specified notification method is triggered. All user<br>
                                            applications that subscribed to the EKG_LastAsyncError field are notified.<br>
                                            The EKG_LastAsyncError field is changed and any notification methods are<br>
                                            triggered when an error message is written to the log as the result of a method<br>
                                            running asynchronously to a user application. RODM writes error log entries when<br>
                                            a method sets its return code to a value greater than or equal to either the user's<br>
                                            EKG_LogLevel or the Log_level customization parameter specified for an<br>
                                            asynchronous method.<br>
                                            <hr>
                                          <h3>Object Deletion Notification</h3>
                                            If your application needs to be notified when certain objects are deleted, the<br>
                                            application can subscribe to those objects with an object-deletion subscription. If the<br>
                                            object is deleted, RODM places a notification block on a notification queue and<br>
                                            posts the ECB for the application.<br>
                                            For the format of the notification block, refer to the description of the<br>
                                            EKG_QueryNotifyQueue response block on page “EKG_QueryNotifyQueue -<br>
                                            Query Notification Queue” on page 427.<br>
                                            The four steps of the RODM notification process (setup, wait, notification, and<br>
                                            cleanup) apply to object-deletion notification, with some differences.<br>
                                          <h4>Setup for Object-Deletion Notification</h4><br>
                                            For object-deletion notification, setup differs from the normal RODM notification<br>
                                            process described on page “Setup” on page 324.<br>
                                            1. Connect to RODM. Do not create a notify subfield, install a notification<br>
                                            method, or subscribe to the field.<br>
                                            2. Create a notification queue and its ECB, as described in Step 4 on page 324. <br>
                                            3. The last step in setup is to subscribe to the object. Your application issues the<br>
                                            EKG_AddObjDelSubs function to create an object-deletion subscription for the<br>
                                            object. This function specifies an object, a user application, and a notification<br>
                                            queue. If the object is deleted, RODM places a notification block on the<br>
                                            specified notification queue and posts the ECB for the user application. Specify<br>
                                            the parameters of this function call as follows:<br>
                                           <b>Entity_access_info_ptr</b><br>
                                            A pointer to the entity access block that specifies the class and object<br>
                                            for which you are creating the object-deletion subscription<br>
                                           <b> User_appl_ID</b><br>
                                            Set this to the null value. RODM fills in the value that corresponds to<br>
                                            the user application that is issuing this function call.<br>
                                           <b>Notification_queue</b><br>
                                            Specify the name of the notification queue you created in Step 4 on<br>
                                            page 324. The User_appl_ID part of the name is supplied by RODM.<br></p>
                                            <hr>
                                            <p><b>User_word</b><br>
                                                You can leave this optional field blank.<br>
                                               <b>Long_lived_parm</b><br>
                                                When the object is deleted, RODM puts the value of this optional<br>
                                                parameter in the user_area parameter of the response block<br>
                                                Repeat Step 3 on page 330 once for each object you subscribe to. The setup for the<br>
                                                deletion-notification process is complete when the EKG_AddObjDelSubs function<br>
                                                has run successfully for each object.<br>
                                              <h3>Wait for Object-Deletion Notification</h3><br>
                                                This step is the same as “Wait” on page 326.<br>
                                             <h3>Notification for Object-Deletion Notification</h3><br>
                                                When the object to which your application has subscribed is deleted, RODM places<br>
                                                a notification block on the application's notification queue and posts the ECB for<br>
                                                the application.<br>
                                                The rest of this step is the same as described in “Notification” on page 328.<br>
                                              <h3> Cleanup for Object-Deletion Notification</h3><br>
                                                To delete an object-deletion subscription, use the EKG_DelObjDelSubs function<br>
                                                described in “EKG_DelObjDelSubs - Delete Object Deletion Subscription” on page<br>
                                                402.<br>
                                                <hr>
                                              <h3> Connecting to RODM</h3>
                                                Before you can run any user API functions, you must connect to RODM using the<br>
                                                EKG_Connect or EKG_ConnectLong API function. When you connect to RODM,<br>
                                                specify an access block containing your user application ID and the name of the<br>
                                                RODM to which you want to connect. RODM sets the Sign_on_token field in your<br>
                                                access block after a successful connect. This value represents your connection to<br>
                                                RODM and must not be changed. If RODM detects that the value in the<br>
                                                Sign_on_token field in your access block is not valid when you request an API<br>
                                                function other than EKG_Connect or EKG_ConnectLong, RODM rejects your API<br>
                                                function request and returns the appropriate reason code.<br>
                                                RODM permits only one connection for each application user ID. Attempts to<br>
                                                connect with a user application ID that is already connected fail, and the<br>
                                                appropriate reason code is returned.<br>
                                                Applications that are cancelled by the operator or are otherwise abended while<br>
                                                they are connected to RODM, are disconnected.<br>
                                                If you chose to disconnect from RODM without purging the subscription<br>
                                                notification queue, upon subsequent connection, all ECB addresses associated with<br>
                                                the notification subscriptions must be reset to point to the new address space ID.<br>
                                                Your application cannot connect to RODM if your application is running in<br>
                                                cross-memory mode. RODM checks for this condition and returns an error reason<br>
                                                code.<br>
                                                After successfully connecting to RODM, RODM creates a user object in the<br>
                                                EKG_User class representing your user application. This user object contains your</p><br>
                                                <hr>
                                                <p>application environment and is preserved until your application disconnects. While<br>
                                                    you can have multiple concurrent API requests executing in RODM for the same<br>
                                                    user application ID, each request uses and possibly modifies the information in the<br>
                                                    user object.<br>
                                                    For more information about connecting to RODM, see “EKG_Connect - Connect to<br>
                                                    RODM” on page 387 or “EKG_ConnectLong - Connect to RODM” on page 388.<br>
                                                    <hr>
                                                 <h3> Disconnecting from RODM</h3>
                                                    When an application completes all of its tasks and has no further API function<br>
                                                    requests to perform, it disconnects using the RODM EKG_Disconnect API function.<br>
                                                    After disconnecting, the sign-on-token is no longer valid. RODM returns an error<br>
                                                    reason code if your application subsequently attempts to run another API function<br>
                                                    request, unless the API function request is an EKG_Connect or EKG_ConnectLong<br>
                                                    function request.<br>
                                                    When your application disconnects, RODM performs clean-up of notification<br>
                                                    queues, depending on the value of EKG_StopMode in your user object. RODM<br>
                                                    might purge all of your user application ID-owned notification queues, queue<br>
                                                    elements, and subscriptions, purge only notification queue elements and retain all<br>
                                                    notification queues and subscriptions, or purge nothing and retain all notification<br>
                                                    queues, queue elements, and subscriptions. If RODM purges all notification<br>
                                                    queues, queue elements, and subscriptions, RODM also purges your user object.<br>
                                                    Note: Applications that end while they are connected to RODM, are disconnected.<br>
                                                    For more information about disconnecting from RODM, see “EKG_Disconnect -<br>
                                                    Disconnect from RODM” on page 404.</p><br>
                                                    <hr>
                                                    <p><h3>Chapter 12. Topology Object Correlation</h3><br>
                                                        This chapter describes the object correlation function. It includes the following<br>
                                                        information: <li>Enabling the correlation function</li> <br>
                                                        <li>Correlation concepts</li><br>
                                                        <li>Including your objects in correlation</li><br>
                                                        <li>Correlating SNA topology manager and MultiSystem Manager objects</li><br>
                                                        <li>Customizing the correlation function</li><br>
                                                        Using correlated aggregate objects, a NetView management console (NetView<br>
                                                        management console) operator can perform the following tasks:<br>
                                                         <li>Navigate between correlated resources</li><br>
                                                        <li>View consolidated data about the correlated resources</li><br>
                                                        <li>Monitor aggregate status of the correlated resources</li><br>
                                                        For more information about using correlated objects, see the<i> IBM Tivoli NetView for<br>
                                                        z/OS User's Guide: NetView Management Console.</i><br>
                                                        <hr>
                                                         <h4>Enabling the Correlation Function</h4>
                                                        Object correlation is enabled by loading the FLCSDM8 input file into RODM. To<br>
                                                        load FLCSDM8, remove the asterisk (*) from the following line in the CNMSJH12<br>
                                                        job:<br>
                                                        //* DD DSN=NETVIEW.V6R2M1.CNMSAMP(FLCSDM8),DISP=SHR <-CORRELATE SAMPL<br>
                                                        Correlation occurs when an application sets a valid value in a field of a RODM<br>
                                                        object that is enabled for correlation. Objects are enabled for correlation by loading<br>
                                                        the FLCSDM8 file. Because MultiSystem Manager and SNA topology manager<br>
                                                        automatically set the value of these fields, which causes correlation to occur, and<br>
                                                        the views are displayed on a NetView management console.<br>
                                                      <h4>Enabling SNA Topology Manager Object Correlation</h4><br>
                                                        To enable correlation for resources managed by SNA topology manager, edit<br>
                                                        initialization file FLBSYSD and change the value of the following statement to YES:<br>
                                                        WRITE_CORRELATABLE_FIELDS=NO<br>
                                                        SNA correlation occurs on PU resources. PU resources are excluded from<br>
                                                        TOPOSNA commands that do not include the LOCAL parameter. Use the LOCAL<br>
                                                        parameter on any TOPOSNA command issued to resources you want included in<br>
                                                        correlation.<br>
                                                        The resources on which SNA topology manager provides a correlator value are PU<br>
                                                        2.1 workstations. If SNA topology manager does not monitor any PU 2.1<br>
                                                        workstations, none of your SNA resources can be correlated. If you know the LAN<br>
                                                        MAC address of your SNA resources, you can include them in correlation. Refer to<br>
                                                        “Extending Correlation of Objects Created by MultiSystem Manager and SNA<br>
                                                        Topology Manager” on page 339.<br></p>
                                                        <hr>
                                                        <p><h3>Enabling GMFHS Object Correlation</h3>
                                                            To enable correlation for GMFHS resources, set a value on one or more of the<br>
                                                            following fields on the GMFHS_Managed_Real_Objects_Class:<br>
                                                             <li>aIndMACAddress</li><br>
                                                            <li>Correlater</li><br>
                                                            <li>iPAddress</li><br>
                                                            The FLCSDM8 RODM load input file creates these fields on the<br>
                                                            GMFHS_Managed_Real_Objects_Class when it is loaded.<br>
                                                            <hr>
                                                           <h3> Correlation Concepts</h3>
                                                            The correlation function is triggered when the value of a field on which the<br>
                                                            FLCMCON method is installed changes. Correlation automatically associates<br>
                                                            resources managed by different agents. The correlation function runs dynamically<br>
                                                            and is implemented using RODM methods. Correlated objects have a common<br>
                                                            correlater value, and a correlated aggregate object is used to represent these objects.<br>
                                                            When correlation is by IP address or MAC address, the correlated aggregate object<br>
                                                            is represented in RODM using aggregateSystem class objects. When correlation is<br>
                                                            by a value in the Correlater field, the correlated aggregate object is represented in<br>
                                                            RODM using GMFHS_Aggregate_Object_Class objects.<br>
                                                            A correlated object is an object of any correlation-enabled class that has a value in<br>
                                                            one of the following fields:<br>
                                                             <li> aIndMACAddress</li><br>
                                                            <li> iPAddress</li>
                                                            <li> Correlater</li>
                                                            This value is the correlater value. <br>
                                                            The term cross-correlation is used to describe the relationship between two or more<br>
                                                            real objects that have an identical correlater value. For example, assume the<br>
                                                            following conditions: 
                                                            <li> The correlation function is enabled.</li><br>
                                                             <li>A system can be part of an internet and part of a sysplex.</li><br>
                                                             <li> The resources are represented by objects in RODM, and, for each object, the</li><br>
                                                            iPAddress field has the value 9.37.65.43.<br>
                                                            Because these two objects have identical values for the same field, the objects are<br>
                                                            cross-correlated.<br>
                                                           <h3> Correlation Methods</h3>
                                                            The following RODM methods implement the correlation function.<br>
                                                            The load and customization of these methods is accomplished using the FLCSDM8<br>
                                                            RODM load file. For more information, refer to “Enabling the Correlation<br>
                                                            Function” on page 333 and “Customizing the Correlation Function” on page 340.<br>
                                                           <h3> FLCMCONI Method</h3>
                                                            The FLCMCONI method is an initialization method that loads the FLCMCON<br>
                                                            method on classes that support correlation. FLCMCONI is used instead of the<br>
                                                            DUIFSTRC RODM load input file because FLCMCONI passes parameters to the<br>
                                                            FLCMCON method.</p><br>
                                                            <hr>
                                                            <p><h4>FLCMCON Method</h4>
                                                                The FLCMCON method is a notification method that is loaded on certain fields of<br>
                                                                classes for which correlation is enabled. To determine which classes are enabled for<br>
                                                                correlation and the fields on which the FLCMCON method is loaded, browse the<br>
                                                                FLCSDM8 RODM load file. FLCMCON runs FLCMCOR.<br>
                                                               <h4>FLCMCOR Method</h4>
                                                                The FLCMCOR method is an object-independent method that creates and updates<br>
                                                                correlated aggregate objects.<br>
                                                              <h3> Objects Enabled for Correlation</h3>
                                                                Loading the FLCSDM8 sample automatically enables correlation for resources that<br>
                                                                are managed by MultiSystem Manager, SNA topology manager, and customer<br>
                                                                applications that use the GMFHS data model. To determine which classes are<br>
                                                                automatically enabled, browse the FLCSDM8 RODM load file. All classes on which<br>
                                                                the FLCMCON method is loaded are automatically enabled.<br>
                                                                For example, the following code enables correlation by IP address on objects of the<br>
                                                                OperatingSystem class, which are created by the MultiSystem Manager IBM Tivoli<br>
                                                                Network Manager feature:<br>
                                                                OP FLCMCONI INVOKED_WITH (SELFDEFINING)<br>
                                                                (
                                                                (OBJECTID) EKG_Method.FLCMCON<br>
                                                                (CLASSID) OperatingSystem<br>
                                                                (FIELDID) ’1.3.18.0.0.3330’.’iPAddress’<br>
                                                                (CLASSID) ’1.3.18.0.0.6464’<br>
                                                                (CLASSID) ’GMFHS_Managed_Real_Objects_Class’<br>
                                                                );
                                                              <h4> Types of Correlation</h4>
                                                                There are two types of correlation: <br>
                                                                <li>Network address correlation</li><br>
                                                                <li>Free-form correlation</li><br>
                                                                Network Address Correlation<br>
                                                                Network address correlation is performed using LAN media access control (MAC)<br>
                                                                or internet protocol (IP) addresses.<br>
                                                                To include objects in correlation based on a network address, set a value on one of<br>
                                                                the following fields: <br>
                                                                <li>aIndMACAddress (1.3.18.0.0.5263)</li><br>
                                                                <li>iPAddress</li><br>
                                                                Correlation uses 12-character MAC addresses (for example, 10004BF00943). A<br>
                                                                14-character MAC address is supported, but the last 2 characters (the link service<br>
                                                                access point) are removed.<br>
                                                                A valid IP address consists of numbers and at least two periods (.) to delimit the<br>
                                                                numbers.<br>
                                                              <h4> Free-Form Correlation</h4>
                                                                Free-form correlation is performed using a free-form string value. Correlation on a<br>
                                                                free-form string creates a correlated object with a display name that matches the<br>
                                                                string value.<br>
                                                                To include objects in free-form correlation, set the string as the value of the<br>
                                                                Correlater field. Example valid values include:<br></p>
                                                                <hr>

<p><li>Accounting</li>
<li>PresidentsOffice</li>
<li>Building201</li>
<li>London</li>
You can also enter a multipart string value in the Correlater field. Entering a<br>
multipart string enables you to link the correlated object to a hierarchy of<br>
correlated aggregate objects as shown in Figure 72:</p><br>
<img src="21.PNG">
<p><i>Figure 72. Correlate Objects on Multiple Free-Form Values</i></p>
<p>To enable correlation to create the objects in Figure 72, set the following values:<br>
   <li>Bridge1 Correlator = 'RmA206 Bldg300 Barcelona Europe' </li><br>
   <li>Switch5 Correlator = 'RmD312 Bldg400 Barcelona' </li><br>
   <li>PBX3 Correlator = 'OpCenter Europe World'</li><br>
  This enables you to create or locate a hierarchy of views, based upon<br>
  organizational or geographic structure, with one command. As with single value<br>
  free-form correlation, for each string value in a multipart string, a correlated<br>
  aggregate object is located or created. If parent relationships do not already exist<br>
  between the different correlated aggregate objects identified in the multipart string,<br>
  they are created.<br>
  Commas or blank spaces can be used to delimit a multi-part string. For example, if<br>
  you enter a string value of Jane Doe, correlation locates or creates two objects –<br>
  Jane and Doe. All of the characters that are supported by the RODM CharVar data type are<br>
  supported. You can use an underscore character (_) between string values that you<br>
  want to be treated as one correlated aggregate object (for example,<br>
  Margaret_Thatcher).</p><br>
  <hr>
  <p>Free-form correlation creates correlated aggregate objects of class<br>
    GMFHS_Aggregate_Objects_Class. This enables correlation to locate and link to<br>
    aggregate objects created by BLDVIEWS scripts. BLDVIEWS typically includes<br>
    objects in views if those objects have a consistent naming scheme (for example,<br>
    CPNRTR2 and CPNHST14), it builds views from the top down. Multiple free-form<br>
    correlation does not require objects to have a similarity in object naming; it builds<br>
    views from the bottom up.<br>
     Using BLDVIEWS and topology correlation together,<br>
      you can build custom views that match your enterprise.<br>
   <h3> Correlated Aggregate Object Classes and Names</h3>
    Correlated aggregate objects are named using the correlater field value of the first<br>
    object for which a correlation was found. Valid values include the following values: <br>
    v LAN MAC address (for example, 40000A17D006)<br>
    v TCP/IP address (for example, 9.37.65.43)<br>
    v Free-form correlater (for example, Accounting)<br>
    Correlated aggregate objects identified through network address correlation are<br>
    created on class aggregateSystem. These objects have a multi-part OSI<br>
    distinguished name that includes a MAC address or TCP/IP address as the last<br>
    element. For example, 1.3.18.0.0.3519=MultiSys,1.3.18.0.0.6467=40000A17D006.<br>
     Correlated aggregate objects identified through free-form correlation are created on<br>
    class GMFHS_Aggregate_Objects_Class. These objects are named by a free-form<br>
    correlater value, with no other prefix or suffix (for example, Accounting).<br>
    For more information about the object names, refer to the aggregateSystem class<br>
    description in the IBM Tivoli NetView for z/OS Data Model Reference.<br>
     Object names are defined by the value of the object MyName field. The name used<br>
    to label these objects on the NetView management console can be either the<br>
    MyName field value or a user-defined value. See “Correlated Aggregate Object<br>
    Display Labels” for more information about display labels.<br>
    <h3>Correlated Object Relationships</h3>
    Resources with identical Correlater field values are represented by one correlated<br>
    aggregate object; this includes resources that are managed by different topology<br>
    agents.<br>
    Relationships are created between correlated resources and correlated aggregate<br>
    objects using links. Links enable more detail, configuration parent, and<br>
    configuration child navigation between objects and status aggregation.<br>
    <h3>Correlated Aggregate Object Display Labels</h3>
    Correlated aggregate objects are displayed using the following symbol:</p><br>
    <img src="22.PNG">
    <p>Correlated aggregate object labels are determined by the first value for which a<br>
      correlation was found:</p>
<hr>
<img src="23.PNG">
<p>Correlated Aggregate Object Field Values<br>
  The correlation function is triggered when the value of a field on which the<br>
  FLCMCON method is installed changes. The FLCMCON method triggers the<br>
  FLCMCOR method. The FLCMCOR method queries the values of the following<br>
  fields of real objects:<br>
   <li> aIndMACAddress</li>
  <li> segmentNumber</li>
  <li>aUniversallyAdministeredAddress</li>
  <li>adapters</li>
  <li> iPAddress</li>
  <li>netAddress</li>
  <li>sysLocation</li>
  <li>adjacentLinkStationAddress2</li>
  <li> linkName</li>
  <li>ipHostName</li>
  <li>Correlater</li>
  The value of these fields is compared to the values of the corresponding fields of<br>
  the correlated aggregate object. When a value exists on a real object but not on the<br>
  correlated aggregate object, the value is copied from the real object to both the<br>
  corresponding field and the DisplayResourceOtherData field of the correlated<br>
  aggregate object.<br>
  Notes:<br>
  1. When a value is assigned to a field on the correlated aggregate object,<br>
  subsequent correlations cannot change the value of the field.<br>
  2. If you write an application that uses the value of these fields, query the<br>
  individual fields rather than parsing the DisplayResourceOtherData field. For<br>
  more information about these fields, see the IBM Tivoli NetView for z/OS Data<br>
  Model Reference. Use the NetView management console to display data contained in the<br>
  DisplayResourcOtherData field. This information is displayed in the NetView<br>
  management console Data1 field.<br>
  The value in the DisplayResourceOtherData field is not always provided by the<br>
  correlation function. Information that is provided by the correlation function is<br>
  identified by a lowercase a in the word address. <br>
  When you set a correlator value in RODMVIEW, the resultant correlation is only<br>
  displayed until the next time that RODM is recycled. That can be days or months,<br>
  depending upon how you run your enterprise. When you set correlator values in a<br>
  CLIST or BLDVIEWS script, you can rerun that CLIST or BLDVIEWS script, and<br>
  restore your customized correlations, after RODM is recycled. For more specifics<br>
  on using BLDVIEWS with topology correlation, see the<i> IBM Tivoli NetView for z/OS<br>
  User's Guide: NetView Management Console</i>.</p><br>
  <hr>
  <p><h3>Using Correlation for Objects You Create</h3>
    Objects discovered by MultiSystem Manager agents and SNA topology manager<br>
    logicalLink class (PU) objects are automatically correlated. You can extend<br>
    correlation to include MultiSystem Manager open data model, GMFHS, and<br>
    additional SNA topology manager objects. For more information about SNA<br>
    topology manager, see “Correlating SNA Topology Manager Objects” on page 340.<br>
    To include objects that you have created in correlation, perform the following<br>
    tasks: v Choose a class to use. You can choose any of the classes enabled for correlation<br>
    in the FLCSDM8 file. Enabling objects of the open data model requires less<br>
    setup, and the FLCSOX01 sample file is provided as an example. If your<br>
    application already creates GMFHS managed resource objects, it is easier to<br>
    continue using the GMFHS objects.<br>
    <li>Set a value on one or more of the following data fields for each object you want<br>
    to include in correlation:</li>
    – aIndMACAddress (for example, 1.3.18.0.0.5263)<br>
    – iPAddress<br>
    – Correlater<br>
    The aIndMACAddress and iPAddress fields support correlation based on<br>
    network addresses and the Correlater field supports free-form correlation.<br>
    You can set field values on the objects using RODMVIEW, CLIST, or BLDVIEWS<br>
    script. The FLCSOX01 sample file provides an example of a REXX CLIST. This<br>
    CLIST demonstrates that if your application already creates RODM objects, you<br>
    can include those objects in correlation by adding just one additional line of<br>
    code</p>
    <hr>
    <p><h3>Extending Correlation of Objects Created by MultiSystem Manager and,<br>
      SNA Topology Manager</h3><br>
      MultiSystem Manager objects and SNA topology manager logicalLink class (PU)<br>
      objects are automatically correlated. If you have correlatable information about<br>
      objects that is not discovered by MultiSystem Manager or SNA topology manager<br>
      agents, you can extend correlation to these objects. To extend the correlation of<br>
      these objects, perform the following tasks:<br>
       <li> Determine the name of the object</li> <br>
       <li>Set a value on the aIndMACAddress, iPAddress, or Correlater field of the object</li><br>
        <li>Perform any data model-specific tasks necessary to extend the objects. See</li><br>
      “Correlating MultiSystem Manager Objects” on page 340 and “Correlating SNA<br>
      Topology Manager Objects” on page 340 for more information.<br>
      Remember that SNA topology manager and MultiSystem Manager dynamically<br>
      create, delete, and update objects. If you add field values and then subsequently<br>
      reacquire topology (for example, by issuing a TOPOSNA or GETTOPO command)<br>
      or cold start RODM, the values you added can be lost. Because of this, use a<br>
      CLIST or BLDVIEWS script to reset correlatable field values each time topology is<br>
      reacquired.<br>
      <h3>How to Determine Object Names</h3><br>
      Object names are defined by the value of the object's MyName field in RODM.<br>
      Remember that the name of an object that is displayed in a view is usually a<br>
      simplified version of the object's name in RODM. The name that is displayed in a</p><br>
      <hr>
      <p>view usually is not suitable for the object name in RODM. Use RODMVIEW to<br>
        determine the MyName field values of existing objects.<br>
        For a description and syntax of MyName fields, refer to the <i>IBM Tivoli NetView for<br>
        z/OS Data Model Reference.</i><br>
        <h3> Correlating MultiSystem Manager Objects</h3><br>
        If the FLCMCON method is loaded directly on the field of an object you want to<br>
        correlate, set a value on the field. To determine which fields have FLCMCON<br>
        loaded, browse the FLCSDM8 RODM load file. This is all that is required for most<br>
        MultiSystem Manager objects.<br>
        If you want to extend additional network address correlation to objects created by<br>
        MultiSystem Manager that have the FLCMCON method loaded on the memberOf<br>
        field, create a link on the memberOf field.<br>
        For example, if you want to add MAC address correlation to a Monitor class object<br>
        that is already correlated on a IP address, create a link on the memberOf field of<br>
        that object. The link can be to any other object, and the process of creating the link<br>
        is the same as creating other links in RODM.<br>
        Note: Free-form correlation using the Correlater field never requires creation of a<br>
        link in RODM.<br>
       <h3>Correlating SNA Topology Manager Objects</h3>
        SNA topology manager logicalLink class objects are automatically included in<br>
        correlation because the value of the adjacentLinkStationAddress field can contain<br>
        the MAC address of the PU. The correlation function determines if this field<br>
        contains a MAC address. If it does, it treats this field like the aIndMACAddress<br>
        field.<br>
        Because SNA Topology Manager does not discover TCP/IP addresses, SNA PUs<br>
        are not correlated to resources on which an IP address is discovered unless the<br>
        MultiSystem Manager IBM Tivoli Network Manager agent also discovers both an<br>
        IP address and a MAC address on that resource. One example of a resource that<br>
        has a MAC address and an IP address is a Windows workstation that has an SNA<br>
        PU and a LAN adapter with IP support. SNA topology manager discovers MAC<br>
        addresses only on Windows workstations.<br>
        To enable IP address correlation for SNA resources, manually set the address on<br>
        the iPAddress field on an object that is enabled in the FLCSDM8 file. Correlation<br>
        can then automatically correlate the SNA object to other resources with IP<br>
        addresses.<br>
        <hr>
       <h3>Customizing the Correlation Function</h3>
        All customization of the correlation function is accomplished using the FLCSDM8<br>
        RODM load file. After customization, FLCSDM8 must be loaded into RODM. If<br>
        FLCSDM8 was previously loaded, cold start RODM. If FLCSDM8 was not<br>
        previously loaded and you have already loaded the other SNA topology manager<br>
        and MultiSystem Manager load files, load FLCSDM8 without cold starting RODM.<br>
        You must use the EKGLLOAD sample file to load FLCSDM8. Ensure that you<br>
        specify the data set and file (FLCSDM8) in the EKGIN3 step.<br>
        There are two ways to customize the correlation function:</p><br>
        <hr>
        <p><li>Change the display name priority</li><br>
        <li>Disable correlation for specific classes</li><br>
          Changing the Display Name Priority<br>
          You can change the type of display name for a correlated aggregate object, when<br>
          that object is correlated by network address. When the object is correlated by<br>
          free-form correlater, the display name is taken from the Correlater field. In that<br>
          case, the type of display name cannot by changed.<br>
          The fields shown in Figure 74 are used to determine the correlated aggregate object<br>
          display name. To determine which correlated aggregate object field is used to label<br>
          an object, the correlate function uses a prioritized list of those fields in the<br>
          FLCSDM8 file. The correlate function queries each field of the aggregate object in<br>
          the order listed until a non-null value is found; this value is used to label the<br>
          object. Table 35 lists the default priority used and the agents for which the<br>
          priorities are used.<br>
          <i>Table 35. Correlated Aggregate Object Default Display Name Priority</i></p>
           <table  border="2" cellpadding="7" cellspacing="7">
            <th>Priority </th><th>Name Type </th><th>Discovered By</th>
           <tr> <td>5</td><td> SNA node name </td><td>SNATM</td></tr>
           <tr><td>6</td><td> LAN MAC address </td><td>SNATM</td></tr></table>
           <p>You can determine which label is displayed by customizing the order in which the<br>
            fields are listed.<br>
            For example, using the default priority shown in Figure 74, a workstation that<br>
            contains a MultiSystem Manager IBM Tivoli Network Manager agent is not named<br>
            using the computer name because the Internet does not define a computer name<br>
            for managed resources. In this case, the workstation object is labeled using its<br>
            internet protocol host name.<br></p>
            <img src="24.PNG">
            <p>Now, assume that you have customized the FLCSDM8 file to put TCP/IP address<br>
              (priority 3) before IP host name (priority 2) as shown in Figure 75 on page 342. In<br>
              this case, the TCP/IP address is used to label the workstation object because the<br>
              MultiSystem Manager IBM Tivoli Network Manager agent provides both an IP<br>
              host name and an IP address, and the IP address name is listed first.</p><br>
              <hr>
              <img src="25.PNG">
              <p><h3>Disabling Correlation for Specific Resources</h3>
                Correlation is enabled for objects of the classes on which the FLCMCON method is<br>
                explicitly loaded in the FLCSDM8 file. If you do not want topology correlation to<br>
                run for a class of managed resource objects, comment out the method load<br>
                statement that loads the FLCMCON file on the class.<br>
                The method load statements are grouped in the FLCSDM8 file by topology agent.<br>
                To determine which method load statement to comment out:<br>
                1. Determine the object display label for a correlated object.<br>
                2. Determine the RODM class that the label represents. Use RODMVIEW to<br>
                determine the class, or refer to the class listings in the IBM Tivoli NetView for<br>
                z/OS Data Model Reference and match the label with the DisplayResourceType<br>
                values listed.<br>
                Note: Using the FLCSDM8 file as shipped, the FLCMCON method is loaded on all<br>
                of the classes which MultiSystem Manager and SNA topology manager can<br>
                automatically correlate upon. It also enables correlation for additional classes you<br>
                might want to extend correlation to. Because the memory and CPU usage for<br>
                loading a method on an unused class is insignificant, it is not necessary to<br>
                comment out the method load statements for unused classes.</p><br>
                <hr>
               <h3> Chapter 13. Writing RODM Methods</h3>
<p>This chapter describes RODM methods. Methods enable you to maintain data in<br>
RODM and to automate functions related to the resources represented by objects in<br>
RODM. Methods are small executable programs that reside in the RODM address<br>
space. They can be run by user applications, by changes to fields in RODM, by<br>
other methods, and at RODM initialization. Methods are classified by the way they<br>
are run.<br>
The NetView program supplies several general-purpose methods that might meet<br>
some or all of your needs. Before you spend time writing your own methods,<br>
review the methods that are supplied with the NetView program as described in<br>
“Supplied Methods” on page 488 for applicability.<br>
 You must install each method, including methods that are supplied with the<br>
NetView program, before you can use it. Each method is represented in RODM by<br>
an object of the EKG_Method class. These objects are created as part of installing<br>
the method. Methods can be dynamically installed, deleted, and refreshed.<br>
<hr>
<h3>Tasks Best Performed with Methods</h3><br>
This section describes which tasks are best performed with methods.<br>
Use a method to do the following: <br>
<li>Perform multiple actions on more than one object or class in the RODM data<br>
cache.</li><br>
You can write an object-independent method to process numerous API functions<br>
against a set of one or more objects or classes. See “Object-Independent<br>
Methods” on page 344 for more information about object-independent methods.<br>
    <li>Load structures and objects at RODM initialization.</li>
The RODM program supports a special form of the object-independent method<br>
called the initialization method. The initialization method can be specified at<br>
RODM start up to provide initialization functions. It can load a class hierarchy<br>
structure and then create objects of the classes. This function enables the RODM<br>
data cache to be established and ready for work following a RODM start up.<br>
The RODM load function can be used as the initialization method. See<br>
“Initialization Method” on page 345 for more information about this method.<br>
<li>Filter data being changed in the RODM data cache.<br></li>
You can write a change method to provide filtering between an application<br>
change API function request and the field being changed in the RODM data<br>
cache. The change method can alter or reject the change API function request<br>
according to policy, security, or validation requirements. See “Change Methods”<br>
on page 346 for more information about this method. <br>
<li>Filter data being queried in the RODM data cache.</li>
You can write a query method to provide filtering between an application query<br>
API function request and the field being queried in the RODM data cache. The<br>
query method can alter the data returned from the query API function request<br>
according to policy, security, or validation requirements. See “Query Methods”<br>
on page 348 for more information about this method.<br>
 <li>Notify applications when data in the RODM data cache changes value</li><br></p>
<hr>
<p>You can write a notify method to notify applications that are subscribed to an<br>
  object or class when field values belonging to the object or class are changed.<br>
  See “Notify Methods” on page 350 for more information about this method. <br>
  v Perform multiple actions on more than one field within an object or class.<br>
  You can write a named method to process numerous API functions against a<br>
  single object or class. See “Named Methods” on page 352 for more information<br>
  about this method.<br>
  <hr>
  <h3>Types of Methods</h3>
  A method is logic in the form of an executable program that is loaded into a<br>
  RODM address space and is run under certain circumstances. Methods are<br>
  classified according to the circumstances under which they are run. Several kinds<br>
  of methods are architected into the RODM product to supply specific kinds of<br>
  functions. All methods are optional, and the function provided by methods can be<br>
  used or not, depending on how classes, objects, and methods are defined,<br>
  organized, and applied in RODM. In broad terms, there are two kinds of methods:<br>
  object-independent methods, and object-specific methods. <br>
  <li>Object-independent methods are like callable subroutines that run inside RODM.<br>
  They can act on many different objects in RODM. Object-independent methods<br>
  are triggered using the EKG_TriggerOIMethod function, which can be issued by<br>
  user applications, by other object-independent methods, and asynchronously by<br>
  object-specific methods.</li><br>
  <li>Object-specific methods are run only in the context of a particular object. For<br>
  example, they are run by transactions that refer to a specific object. When an<br>
  object-specific method is running, it has access only to the data in the fields and<br>
  subfields of that object. Object-specific methods in RODM can be triggered as<br>
  side effects of a transaction the query, change, and notify methods previously<br>
  described or by explicit reference (named methods that are run upon explicit<br>
  request).</li>
  Methods can refer to data and manipulate data in RODM objects. Through the<br>
  routines in the method API, methods can query and change the fields and<br>
  subfields of the RODM objects to which the methods have access. Methods must<br>
  use the method API to access data in the RODM data cache.<br>
  The different methods and their uses are described on the following pages. A<br>
  pseudocode description of the method interface is included with each explanation.<br>
  These descriptions describe only the parameters, not the exact interface. The<br>
  parameters are assumed to be passed to the method by address. The pseudocode<br>
  examples (in PL/I style) are not intended to imply PL/I parameter passing<br>
  conventions, such as using descriptors for structures. The method interface is<br>
  intended to be consistent with the user API style of interface where parameters are<br>
  pointers directly to the passed data.<br>
  <h3>Object-Independent Methods</h3><br>
  Object-independent methods are like callable subroutines that run inside RODM.<br>
  They are not associated with any particular RODM object or class. They can act on<br>
  many different objects in RODM. Object-independent methods are triggered using<br>
  the EKG_TriggerOIMethod function, which can be issued by user applications, by<br>
  other object-independent methods, and asynchronously by object-specific methods.<br>
  Object-independent methods have these characteristics:<br>
   <li>They can be run from the user API or the method AP</li></p>
   <hr>
   <p><li>They can be run by a method for asynchronous execution.</li><br>
     <li> They can access fields in multiple objects. </li><br>
     <li>They can issue multiple method API requests to RODM without the target</li><br>
    objects being affected by other transactions.<br>
    Object-independent method parameters are short-lived parameters. These<br>
    parameters are defined using the SelfDefining data type and contain<br>
    application-defined values. These parameters are established dynamically from the<br>
    EKG_TriggerOIMethod function.<br>
    While the standard query and change transactions that a user can submit against<br>
    RODM are restricted to interactions with one object, an object-independent method<br>
    can interact in sequence with, or at the same time with, each of several different<br>
    objects. An object-independent method has access to all the objects in RODM<br>
    through the method API.<br>
    RODM manages the interaction of transactions to ensure that all actions are<br>
    completed against target entities before allowing access to the entities by other<br>
    transactions.<br>
    Object-independent methods have no long-lived parameters associated with them.<br>
    One SelfDefining data string, of variable length (up to a maximum of 32767 bytes),<br>
    is the only parameter passed to an object-independent method when the method is<br>
    run. RODM does not restrict the contents of that string. You must coordinate the<br>
    parameter passed when the method is run with the parsing and meaning that the<br>
    message attaches to the string of bytes that is passed.<br>
    Figure 76 shows how an object-independent method is defined in PL/I. Figure 77<br>
    shows how an object-independent method is defined in C.</p>
    <img src="26.PNG">
    <p><b><h3>Initialization Method</h3></b>
      The initialization method is a special kind of object-independent method. It is run<br>
      by RODM at initialization time. When RODM is started with the initialization<br>
      method, RODM installs, runs, and then frees the method automatically. The main<br>
      purpose of the initialization method is to set up the initial hierarchy of the RODM<br>
      data cache. Some functions can be used only by the initialization method. The<br>
      RODM load function can be used as the RODM initialization method.</p>
      <hr>
      <p>Object-Specific Methods<br>
        Object-specific methods are as follows: <br>
        <li> Run implicitly as the side effect of a transaction</li><br>
        – Query method (when querying data)<br>
        – Change method (when changing data)<br>
        – Notify method (after changing data)<br>
        <li>Run explicitly by request through RODM User or Method API</li><br>
         – Named method (by specifying field name)<br>
        Change Methods<br>
        A change method is triggered by RODM when a transaction issues the<br>
        EKG_ChangeField or EKG_ChangeMultipleFields function request to change the<br>
        value of a field and that field has a change method defined. A change method is<br>
        not triggered, however, when a transaction issues the EKG_ChangeSubfield<br>
        function request to change the value in the value subfield of the field. A change<br>
        method: <br>
        <li>Determines the final value of field to be changed, with the exception of fields of<br>
        type ObjectLink and ObjectLinkList. Change methods defined on these fields do<br>
        not change the value of the field. Instead, they determine whether a link or<br>
        unlink action can proceed.</li><br>
         <li>Is inherited unless locally overridden.</li><br>
        <li>Runs in context of a class or object being changed.</li><br>
        The change method parameters are as follows:<br>
        <b>field_id</b><br>
        FieldID of the field being changed.<br>
       <b> long_lived_parms</b><br>
        A SelfDefining string containing application-defined parameters. These<br>
        parameters are provided to the change method when it is installed.<br>
       <b> short_lived_parms</b><br>
        A SelfDefining string containing application-defined parameters. These<br>
        parameters are provided to the method dynamically during the API<br>
        function request that triggers the change method.<br>
       <b> data_type</b><br>
        RODM data type of the field being changed.<br>
       <b> CharDataLen</b><br>
        The integer length of the new_data if data_type is CharVar or GraphicVar.<br>
         This length does not include the null terminator for these data types.<br>
        <b>New_data</b><br>
        New data for the field from the API call.<br>
        A change method can be associated with a field of an object as a subfield of that<br>
        field. A change method is run every time a transaction is run (a user API or<br>
        method API transaction) that changes the contents of the field. A change<br>
        transaction whose target is a simple field triggers whatever change method has<br>
        been assigned to the change subfield of the target field. Change methods can be<br>
        triggered by these transactions through either the user API or method API.<br>
        A change method is also triggered when a transaction issues the EKG_LinkTrigger<br>
        function request or the EKG_UnlinkTrigger function request to link two fields in<br></p>
        <hr>
        <p>two objects and those fields have change methods defined. These change methods<br>
          cannot change the value of the fields. The change methods must set a return code<br>
          to indicate whether the link or unlink can proceed. If the change methods do not<br>
          exist, or if they do not explicitly set the return code, RODM assumes the return<br>
          code is zero and the link or unlink proceeds. Change methods on fields other than<br>
          ObjectLink and ObjectLinkList are run only when the field on which they are<br>
          defined is directly changed. A change method is not run when the same field on<br>
          the parent class is changed and the changed value is inherited. A change method is<br>
          not run by changes in a child object or class. A change method is not run by<br>
          changes to subfields. The triggering of change methods can be avoided by the use<br>
          of transactions that manipulate the value subfield of a field.<br>
          If a field has a change method defined on it, that change method is responsible for<br>
          making any changes to the value of that field; RODM will not change the value of<br>
          that field. The change method must use the EKG_ChangeSubfield function to<br>
          update the value subfield of the field. If the change method uses the<br>
          EKG_ChangeField or EKG_ChangeMultipleFields functions to update the value<br>
          subfield, the change method recursively runs itself. RODM detects and blocks the<br>
          recursive method execution but does not change the value subfield.<br>
          If a change method needs to interact with a resource outside of RODM, it sends<br>
          any request to the resource asynchronously and set the appropriate flags to<br>
          indicate that the request has been sent. The change method does not wait for a<br>
          reply from the real resource before it continues processing.<br>
          A change method is associated with a specific field of a specific object. Only a<br>
          change to that specific field of that object triggers the change method to be run.<br>
          Change methods for a field of an object can automatically exist on the object by<br>
          inheritance at the time the object is created. A change method on a field of an<br>
          object is not triggered by the creation or deletion of that object.<br>
          A change subfield has data type MethodSpec. The MethodSpec data type identifies<br>
          the method that is run. It optionally contains long-lived parameters that are passed<br>
          to the method when it is run. The long-lived parameters can be used to adapt a<br>
          general purpose method to a particular situation.<br>
          The long-lived parameters can be a list of field identifiers. They are defined when<br>
          the method is assigned to the change subfield. The list of field identifiers is static.<br>
          However, the values in the fields are dynamic; they can be changed at any time.<br>
          A method can read the contents of fields through the method API. So with a list of<br>
          field identifiers specifying which fields contain its parameters, a change method<br>
          can find its own execution-time parameters and take the intended actions. Most<br>
          methods are written as general-purpose methods by IBM, and several parameters<br>
          might be required to adapt the general-purpose method to the specific function to<br>
          be performed to manage a change to a field. This design has the advantage of<br>
          making parameters to methods visible through the user API for debugging<br>
          purposes.<br>
          Another parameter (besides the long-lived parameters) is passed to a change<br>
          method when the method is run. The function blocks in the user API and method<br>
          API for changing fields all include a short-lived parameter, which is SelfDefining<br>
          data with a maximum length of 254 bytes. When a function block is filled in, a<br>
          requestor can use these 254 bytes for any data that needs to be passed at<br>
          invocation time to any methods triggered by the transaction<br></p>
          <hr>
          <p>To change the value subfield of the field, the change method obtains the data<br>
            supplied through the API. That information is passed as the fourth and fifth<br>
            parameters.<br>
            Figure 78 shows example change method parameters for PL/I. Figure 79 shows<br>
            example change method parameters for C.<br>
            Note: For data types of CharVar and GraphicVar, the input data strings are null<br>
            terminated: CharVar strings by X'00', GraphicVar strings by X'0000'.<br>
            The return code and reason code for the entire transaction can be controlled from a<br>
            change method through calls in the method API available to the method.<br>
            Through the method API, a change method has access to:<br>
             <li>Data in fields and subfields of the object upon which it is acting</li><br>
            <li>A copy of the function block that triggered this method</li><br>
            <li>Organization of the object including data types of fields</li><br>
            Some of the things a change method can do are the following:<br>
            <li>Stop a transaction upon an error condition and set the return and reason codes<br>
            using the EKG_SetReturnCode function.</li><br>
            <li>Change fields and subfields of the target object using the EKG_ChangeSubfield<br>
            function.</li><br>
            <li>Add a notification using the EKG_AddNotifySubscription function. </li><br>
            <li>Take actions on other objects using the EKG_MessageTriggeredAction function.</li><br>
            <li>Write to the RODM log using the EKG_OutputToLog function.</li><br>
            Query Methods<br>
            A query method is run by RODM when a transaction queries the value of a field;<br>
            but not run when the value subfield is explicitly queried. The query method: <br>
          <li>Can determine final returned data value of the field being queried</li><br>
          <li>Is inherited unless locally overridden</li><br>
            ChngMeth: Procedure ( Field_ID, LLParms, SLParms, DataType, CharDataLen, DataPtr )<br>
            Dcl Field_ID FieldID; /* target field of transaction */<br>
            Dcl LLParms SelfDefiningDataPtr; /* Pointer to Long-lived field parameters */<br>
            Dcl SLParms SelfDefiningDataPtr; /* Pointer to Short-lived Parameter */<br>
            Dcl DataType Smallint; /* Data type of field */<br>
            Dcl CharDataLen Integer; /* Valid for data type CharVar and GraphicVar */<br>
            Dcl DataPtr pointer; /* Pointer to new data from API call */<br>
            . . . .<br>
            /* code */<br>
            . . . .<br>
            End;<br>
            Figure 78. Change Method Procedure Interface for PL/I<br>
            VOID ChngMeth(FieldID *in_FieldID,<br>
            SelfDefiningDataPtr **in_LLParms,<br>
            SelfDefiningDataPtr **in_SLParms,<br>
            Smallint *in_DataType,<br>
            Integer *in_CharDataLen,<br>
            Pointer **in_DataPtr);<br>
            ....<br>
            /* code */<br>
            .... Figure 79. Change Method Procedure Interface for C</p><br>
            <hr>
            <p>Runs in context of a class or object being queried<br>
              The query method parameters are:<br>
              <b>field_id</b><br>
              FieldID of the field being queried.<br>
             <b> long_lived_parms</b><br>
              A SelfDefining string containing application-defined parameters. These<br>
              parameters are provided to the query method when it is installed.<br>
              <b>short_lived_parms</b><br>
              A SelfDefining string containing application-defined parameters. These<br>
              parameters are provided to the method dynamically during the actual API<br>
              function request that triggers the query method.<br>
              Query methods can be associated with fields of objects. If a query method is<br>
              defined for a field, the method is run each time the field is queried using the<br>
              EKG_QueryField function through the user API or method API. If a query method<br>
              is defined, it is responsible for returning a value for the field to the function that<br>
              queried the field. The query method can return the current value of the field, or<br>
              the method can return some other value. For example, a query method can issue a<br>
              command to some real resource to get the current status of that real resource.<br>
              The query can use the EKG_ResponseBlock function to write its response to the<br>
              caller-provided response block. If the query method does not use the<br>
              EKG_ResponseBlock function, RODM returns the data in the queried field to the<br>
              query function. A query method can generate the actual value that is returned. It<br>
              can check time stamps to verify that the value of a field is current. If you do not<br>
              want to trigger a query method, use the EKG_QuerySubfield function to query the<br>
              value subfield of the field rather than querying the field itself.<br>
              If a query method submits a command to a real resource to obtain information, it<br>
              returns immediately to the caller with a reason code indicating that a request for<br>
              new data has been submitted. No method enters a WAIT state.<br>
              A query method is associated with a specific field of a specific object. Only a query<br>
              of that field of that object triggers the query method to be run.<br>
              A query subfield has data type MethodSpec. A query subfield can preserve the<br>
              name of a query method to be run and a list of field identifiers specifying<br>
              (long-lived) field parameters to be used by the query method in customizing its<br>
              behavior to the particular object, field, and environment where the query method<br>
              is executing. The query method can read the contents of the field parameters using<br>
              routines available through the method API.<br>
              A short-lived parameter is also extracted from the function block submitted by the<br>
              requesting application and passed to a query method at the time of invocation.<br>
              Figure 80 on page 350 shows an example of query method parameters for PL/I.<br>
              Figure 81 on page 350 shows an example of query method parameters for C.</p><br>
              <hr>
              <p>QueryMeth: Procedure ( Field_ID, LLParms, SLParms );<br>
                Dcl Field_ID FieldID; /* target field of transaction */<br>
                Dcl LLParms SelfDefiningDataPtr; /* Pointer to Long-lived field parameters */<br>
                Dcl SLParms SelfDefiningDataPtr; /* Pointer to Short-lived Parameter */<br>
                . . . .<br>
                /* code */<br>
                . . . .<br>
                End;<br>
                Figure 80. Query Method Procedure Interface for PL/I<br>
                VOID QueryMeth(FieldID *in_FieldID,<br>
                SelfDefiningDataPtr **in_LLParms,<br>
                SelfDefiningDataPtr **in_SLParms);<br>
                ....<br>
                /* code */<br>
                .... Figure 81. Query Method Procedure Interface for C<br>
                Notify Methods<br>
                Notification methods are run by RODM after certain functions are made. To<br>
                determine which functions run notification methods, see the description for the<br>
                function in Chapter 14, “Application Programming Reference,” on page 371.<br>
                A notification method: <br>
                <li> Generates notifications to subscribed users</li><br>
                <li> Is inherited only from class to object </li><br>
                <li> Runs in context of a class or object being changed</li><br>
                <li>Can propagate knowledge of field changes to:</li><br>
                – Other objects<br>
                – Subscribed users<br>
                The notification method parameters are as follows:<br>
               <b> field_id</b><br>
                FieldID of the field that was changed.<br>
                <b>long_lived_parms</b><br>
                SelfDefining string containing application-defined parameters. These<br>
                parameters are provided to the notification method when it is installed.<br>
               <b> short_lived_parms</b><br>
                SelfDefining string containing application-defined parameters. These<br>
                parameters are provided to the method dynamically during the actual API<br>
                function request that triggers the notification method.<br>
               <b> change_status</b><br>
                Specifies whether or not the changed field value is equal to the old field<br>
                value.<br>
                <b>user_appl_id</b><br>
                UserID of the user that is to receive the notification.<br>
                <b>notif_queue_id</b><br>
                Name of the notification queue that is to receive the notification.<br>
                <b>user_word</b><br>
                User-supplied information.<br>
                A list of notification methods is associated with each field of a class or object that<br>
                has a notify subfield present. The list is called the subscription list for the field.</p><br>
                <hr>
                <p>Every time a field is changed, the associated subscription list of notification<br>
                  methods is processed, and each method in the list is run. The intent of these<br>
                  methods is to propagate knowledge of changes both to other objects and to<br>
                  applications outside RODM that need to be informed about changes. Notification<br>
                  methods can include logic to selectively notify, such as to notify only when a<br>
                  threshold is surpassed.<br>
                  When a change transaction is specified against a field, all notification methods<br>
                  defined on that field are triggered. These notification methods are triggered<br>
                  regardless of whether or not a change method is defined on the field and whether<br>
                  or not the value of the field actually changes. Each notification method is passed a<br>
                  Change_status parameter by RODM, which informs the method whether or not the<br>
                  value of the field was changed by the change transaction.<br>
                  To avoid triggering notification methods, use functions that do not trigger<br>
                  methods. These functions do not trigger notification methods:<br>
                  <li>EKG_LinkNoTrigger</li><br>
                  <li>EKG_UnlinkNoTrigger</li><br>
                  <li>EKG_ChangeSubfield</li><br>
                  <li>EKG_SwapSubfield</li><br>
                  The subscription list on the child is not processed, and the notification methods are<br>
                  not run. Notification methods are active only when values in fields are locally<br>
                  present. This practice is similar to the practice of avoiding triggering change<br>
                  methods where the value in the associated field is inherited, and a change is made<br>
                  to the parent field.<br>
                  Some notification methods can delete themselves after their first execution. For<br>
                  example, an application submits a RODM transaction that causes a command to be<br>
                  submitted to the target system where the command is attempting to vary a device<br>
                  offline. Completion of the request takes time.<br>
                  The transaction cannot wait for the response, and the application needs to be<br>
                  informed when the command is complete. The code, which might be a change<br>
                  method implementing the original transaction, places a notification method in the<br>
                  subscription (notification) queue for the field. When the device is varied offline, the<br>
                  notification method pulls itself out of the subscription queue and notifies the<br>
                  original application that the requested vary command has been successfully run.<br>
                  When a method calls the EKG_AddNotifySubscription function, that method must<br>
                  acquire the required information, identified by the data type SubscriptSpec, to<br>
                  actually perform the function. This information is obtained through<br>
                  long-lived-parameters and short-lived-parameters.<br>
                  Notification methods are placed in the subscription list of a field upon an explicit<br>
                  request made by an application using the EKG_AddNotifySubscription function in<br>
                  the user API and method API. Notification methods can be deleted from a<br>
                  subscription list using the EKG_DeleteNotifySubscription function.<br>
                  The subscription list for a field is always processed in the order that the<br>
                  notification methods were placed in the subscription queue. The methods are<br>
                  processed, one at a time, starting with the first method placed in queue.<br>
                  There is another issue of how inheritance interacts with notification methods.<br>
                  Notification subscriptions are not inherited from a parent class to a child class.<br>
                  However, they are effectively inherited from a class to an object, where the class is</p><br>
                  <hr>
                  <p>the primary parent of the object. Notification subscriptions can be associated with<br>
                    any class or object. When it is associated with a class and that class field changes,<br>
                    the notification list on that class field is run. When a change is made to an object<br>
                    field, the notification subscriptions assigned to the field in that object are run. Any<br>
                    notification subscriptions assigned to the same field in the primary parent are also<br>
                    run, enabling you to use a single notification subscription at the class level for all<br>
                    objects in the class. Methods assigned to an object parent class can use the<br>
                    “WhereAmI” method API to determine the circumstances under which their<br>
                    execution has been triggered.<br>
                    The NetView program supplies four sample notification methods in source format.<br>
                    Study these methods to learn more about writing your own notification method.<br>
                    The sample methods are the following members of the CNMSAMP data set:<br>
                    <li>EKGNEQL</li><br>
                    <li>EKGNLST</li><br>
                    <li>EKGNOTF</li><br>
                    <li>EKGNTHD</li><br>
                    These methods are described in “RODM Notification Methods” on page 489.<br>
                    Figure 82 shows an example of notification parameters for PL/I. Figure 83 shows<br>
                    an example of notification parameters for C.<br>
                    NotifMeth: Procedure ( FieldID, LLParms, SLParms, Change_status,<br>
                    User_Appl_ID, Notif_queue_ID, User_word );<br></li>
                    Declare<br>
                    FieldID Field-identifier, /* Field-identifier of named field *<br>
                    LLParms SelfDefiningDataPtr, /* Pointer to Long-lived field parameters */<br>
                    SLParms SelfDefiningDataPtr, /* Pointer to Short-lived Parameter */<br>
                    Change_status Smallint, /* 0 specifies new data was equal to data*/<br>
                    /* 1 specifies new data was not equalold data*/<br>
                    User_Appl_ID ApplicationID, /* unique User identifier */<br>
                    Notif_queue_ID SubscribeID, /* Notification queue reference */<br>
                    User_word Anonymous(8); /* remote user spec */<br>
                    . . . .<br>
                    /* code */<br>
                    . . . .<br>
                    End;<br>
                    Figure 82. Notification Method Procedure Interface for PL/I<br>
                    VOID NotiMeth(FieldID *in_FieldID,<br>
                    SelfDefiningDataPtr **in_LLParms,<br>
                    SelfDefiningDataPtr **in_SLParms,<br>
                    Smallint *in_Change_status,<br>
                    ApplicationID **in_User_Appl_ID,<br>
                    SubscribeID **in_Notif_queue_ID,<br>
                    Anonymous **in_User_word);<br>
                    ....<br>
                    /* code */<br>
                    .... Figure 83. Notification Method Procedure Interface for C<br>
                   <b>Named Methods</b><br>
                    A named method is indicated by a field defined as MethodSpec, containing: <br>
                    <li>Method object ID</li><br>
                    <li>Long-lived method parameters</li><br>
                    A named method:<br>
                    <li>Allows for multiple coordinated actions against an object<br></p>
                      <hr>
                      <p><li>Named method field can also have query, change, notify, prev_val, and time<br>
                        stamp subfields</li><br>
                        The named method parameters are:<br>
                        <b>field_id</b><br>
                        FieldID of the field being run.<br>
                        <b>long_lived_parms</b><br>
                        SelfDefining string containing application-defined parameters. These<br>
                        parameters are provided to the named method when it is installed.<br>
                       <b> short_lived_parms</b><br>
                        SelfDefining string containing application-defined parameters. These<br>
                        parameters are provided to the method dynamically during the actual API<br>
                        function request that triggers the named method.<br>
                        The method is considered named because it can be referenced (queried, changed<br>
                        and triggered) using the field name. The field name represents a field in an object<br>
                        with the data type of MethodSpec. A field of this type contains a method name<br>
                        and a list of long-lived field parameters that are available to the method when the<br>
                        method is run. Explicit actions available in the user API and method API are used<br>
                        to trigger named methods.<br>
                        Named methods enable you to change more than one field of a class or object.<br>
                        RODM locks all of the fields of the target object when a named method is run. No<br>
                        other method or user application can access those fields until the named method<br>
                        completes. This enables you to coordinate the updates to several fields on a target<br>
                        class or object.<br>
                        Because many named methods can all be associated with all objects of a class,<br>
                        named methods are typically inherited from the class. Many standard transactions<br>
                        against objects can be implemented by either methods that are supplied with the<br>
                        NetView program or user-written methods.<br>
                        A field of data type MethodSpec, a named method field, can have its own query,<br>
                         change, notify, and other standard subfields. The data in the value subfield of such<br>
                        a field includes the method name and a list of field parameters. The specified field<br>
                        parameters can be the targets of actions taken by the named method, or they can<br>
                        contain arguments to the execution of the named method. As with query and<br>
                        change methods, the long-lived list of field parameters is determined when the<br>
                        named method field is assigned a value. The contents of any fields referenced<br>
                        through the long-lived parameters can be set at any time.<br>
                        Besides the field parameters, another parameter can be passed at execution time to<br>
                        a named method by the application that triggers the method. This is called a<br>
                        short-lived parameter. Unlike long-lived field parameters, it is not preserved in any<br>
                        way after the named method has run. All short-lived parameters on named<br>
                        methods must be of data type SelfDefining of maximum length 254. Such<br>
                        short-lived parameters are a variable length string of bytes that can be structured<br>
                        in any way that the requesting application and the named method are written to<br>
                        recognize.<br>
                        The NetView program supplies a sample named method in source format. Study<br>
                        this method to learn more about writing your own named method. The sample<br>
                        method is the member EKGMIMV of the CNMSAMP data set. This method is<br>
                        described in “RODM Named Methods” on page 493.</p>
                        <hr>
                        <p>Figure 84 shows an example of named method parameters for PL/I. Figure 85<br>
                          shows an example of named method parameters for C.<br></p>
                          <p>NamedMeth: Procedure ( Field_ID, LLParms, SLParms );<br>
                            Dcl Field_ID FieldID; /* Field-identifier of named field */<br>
                            Dcl LLParms SelfDefiningDataPtr; /* Pointer to Long-lived field parameters */<br>
                            Dcl SLParms SelfDefiningDataPtr; /* Pointer to Short-lived Parameter */<br>
                            . . . .<br>
                            /* code */<br>
                            . . . .<br>
                            End;<br>
                            Figure 84. Named Method Procedure Interface for PL/I<br>
                            VOID NamedMeth(FieldID *in_FieldID,<br>
                            SelfDefiningDataPtr **in_LLParms,<br>
                            SelfDefiningDataPtr **in_SLParms);<br>
                            ....<br>
                            /* code */<br>
                            ....<i>Figure 85. Named Method Procedure Interface for C</i><br></p>
                            <p>A named method has access to the same data, and has the same abilities as query,<br>
                              and change methods. However, the explicit invocation of named methods is at the<br>
                              discretion of applications using RODM, and named methods are free form in the<br>
                              function that they provide if the function can be implemented with the available<br>
                              data and services.<br>
                              <h3>Inheritance in Object-Specific Methods</h3><br>
                              Query, change, notify, and named methods are all object-specific methods. Of these<br>
                              methods, only named methods are values in fields of RODM objects.<br> 
                              Query, change, and notify methods are all stored in subfields of objects. On an object, the<br>
                              named method fields and subfields on fields are inherited from the subfields of the<br>
                              public classes of that object.<br>
                              In the same way, the values in named method fields and the values in query and<br>
                              change subfields can be inherited through primary inheritance, using the standard<br>
                              principles for supporting inheritance in RODM. Notify methods are inherited from<br>
                              the primary parent to its object children. They are not inherited throughout the<br>
                              class inheritance tree. However, the object fields can additionally have local values<br>
                              that do not override the class-level notification subscriptions. (So standard<br>
                              inheritance of values does not apply to notification subfields.)<br>
                              Named methods, query methods, change methods and notification methods can<br>
                              also all exist on classes. Change methods on classes (as on objects) can be used to<br>
                              validate changes before they are made, or they can be used to validate a user's<br>
                              authority to make those changes. Query methods can validate a requestor's<br>
                              authority to see the requested data, or they can validate data before it is returned.<br>
                              Likewise, named methods on classes can be used in ways similar to the ways such<br>
                              methods are used on objects. Complex changes to a class can be run by a named<br>
                              method, or general-purpose functions, applicable to many individual classes, can<br>
                              be implemented with named methods. Finally, notification methods are also<br>
                              valuable on classes.<br>
                              Change and notification methods on children that are inheriting values from<br>
                              parents are not triggered when the inherited values are changed on parents.<br></p>
                              <hr>
                              <p>Therefore, notification methods are required on parents (which can be classes) so<br>
                                that user applications can be notified when parameters and values change on<br>
                                parents.<br>
                                The main purpose of the primary hierarchy of classes is to make it easy to specify<br>
                                the organization of and default values in RODM objects. The most common values<br>
                                that are inherited at the object level from the primary hierarchy include:<br>
                                 <li> Methods and parameters to control the management of RODM data to reflect<br>
                                real-world objects</li><br>
                                <li>Policy parameters that indicate standard limits and thresholds</li><br>
                                <li>Long-lived characteristics, such as capacity, of RODM objects where those<br>
                                characteristics are needed to manage real-world objects</li><br>
                                These methods and values appear in fields on classes so they can be stated once<br>
                                and then inherited by many objects through the primary hierarchy.<br>
                                 When a value that is a method is inherited by a child, if that method is triggered<br>
                                and run for a child, execution takes place in the context of the child. While the<br>
                                method resided on the parent, only its name and its long-lived parameters are<br>
                                picked up through the inheritance process. When such a method runs and asks for<br>
                                the contents of a field, it gets the contents of that field on the child entity.<br>
                                 A query, change, or named method installed on a class can fill two roles. The<br>
                                method can be the default change method inherited by children and applied in the<br>
                                context of those children (including children that are objects instead of classes), and<br>
                                it can be triggered in the standard way (query, change of field, direct invocation) in<br>
                                the context of the parent.<br>
                                Be aware that object-specific method you write can sometimes run on an object<br>
                                and at other times can run on a class. The same kinds of capabilities are available<br>
                                for both objects and classes, using the same method API calls. Many object-specific<br>
                                methods look at the WhatIAm field on the current entity to discover the context in<br>
                                which the method is executing, and different actions might be appropriate in<br>
                                different contexts.<br>
                                Query, change, named, and notification methods on fields of classes are triggered<br>
                                as part of transactions against those classes just as those kinds of methods are<br>
                                triggered on objects. Also, query, change, and named methods exist on fields of<br>
                                classes to support inheritance of those methods by objects, but inheritance of<br>
                                values in notification subfields is not supported in RODM.<br>
                                If a notification list exists through inheritance, it begins as a null value. A null<br>
                                value in the notification list field is functionally equivalent to no list at all. Entries<br>
                                can be added to a notification list by using the EKG_AddNotifySubscription<br>
                                function.<br>
                                In summary, named methods and query, change, and notify subfields all function<br>
                                in the standard way both on private and on public fields of classes. There is no<br>
                                inheritance involving private fields, but query, change, and notification methods<br>
                                are run when the corresponding field is queried or changed. When a field is on a<br>
                                class (as with fields on objects), a change transaction for the field triggers change<br>
                                and notification methods, but a change transaction for the value subfield of a field<br>
                                does not trigger change and notification methods. This function is the same as that<br>
                                supported for objects</p>
                                <hr>
                                <p><h3>Null Method</h3>
                                  RODM provides a special method named NullMeth. You can use the NullMeth<br>
                                  object ID in place of any object specific method. NullMeth returns control to its<br>
                                  caller without doing any processing. The value NullMeth can be inherited in a<br>
                                  field or subfield from a parent class. If the value of a field of type MethodSpec is<br>
                                  queried for a null method, the ObjectID for NullMeth is returned in the response<br>
                                  block.<br>
                                  Using the NullMeth method name, a query or change subfield that is inherited can<br>
                                  be set to do nothing. The effect is the same as if the local subfield does not exist.<br>
                                  This is useful where the standard function for a field or subfield is to take some<br>
                                  action, but there are a few exceptions where that function is locally overridden to<br>
                                  do nothing.<br>
                                  Similarly, an empty notification list acts like no list exists. If the corresponding field<br>
                                  changes, no notification methods are triggered, and no one is notified of the event.<br>
                                  <hr>
                                 <h3> Deciding Which Method Type to Use</h3><br>
                                  Before you use a method, you must decide which type of method you need to use.<br>
                                  What type of method you use depends on the task you want the method to<br>
                                  perform.<br>
                                 <h3>When to Use an Object-Independent Method</h3>
                                  You use an object-independent method if you want to efficiently manipulate more<br>
                                  than one entity in the RODM data cache. An object-independent method can<br>
                                  change or query any field in any class or object in the RODM data cache.<br>
                                 <h3>When to Use an Object-Specific Method</h3><br>
                                  Object-specific methods are methods that have entities specifically associated with<br>
                                  them. You use an object-specific method if you want to manipulate only one entity<br>
                                  in the RODM data cache. The specific entity that is manipulated is determined at<br>
                                  run time and can be different each time that the method is triggered. To run an<br>
                                  action against another object or class, an object-specific method can use the<br>
                                  EKG_MessageTriggeredAction function. An object-specific method can also trigger<br>
                                  the notification method to inform a user application about an event.<br>
                                  There are four types of object-specific methods:<br>
                                  <li>Query method></li><br>
                                  <li>Change method</li><br>
                                  <li>Notify method</li><br>
                                  <li>Named method</li><br>
                                  Each of these methods is designed to perform a specific task and can perform that<br>
                                  task only on the entity to which it is associated; it cannot access fields in any other<br>
                                  entity. Additionally, object-specific methods can call only the API functions that are<br>
                                  designed to be callable from these methods. See “Other Services Available to<br>
                                  Object-Specific Methods” on page 368 for a list of API functions that are available<br>
                                  to object-specific methods.<br>
                                <h4>  Query Method</h4>
                                  This object-specific method is triggered when a field that has a non-null query<br>
                                  subfield is queried in response to an EKG_QueryField API function. The query<br>
                                  method ensures that the data returned to the caller of the EKG_QueryField API<br>
                                  function is correct and current.</p>
                                  <hr>
                                  <p>Use this method to refresh data in an entity field that might be outdated or to<br>
                                    enforce policy procedures, validation, or security on the data in the field.<br>
                                    Change Method<br>
                                    This object-specific method is triggered when a field that has a non-null change<br>
                                    subfield is changed in response to an EKG_ChangeField function, an<br>
                                    EKG_ChangeMultipleFields, an EKG_LinkTrigger function, or an<br>
                                    EKG_UnlinkTrigger function. The change method ensures that the functions<br>
                                    change, link, or unlink the fields correctly by enforcing data security, data validity,<br>
                                     and even policy requirements.<br>
                                    Use this method to enforce policy procedures, validation, or security on the data in<br>
                                    an entity field.<br>
                                  <h4> Notify Method</h4>
                                    This object-specific method is triggered when the value in a field that has a<br>
                                    non-null notify subfield is changed. The notify method notifies the applications<br>
                                    that are subscribed to the field that the value of the field has changed.<br>
                                    Use this method to notify an application program of a change in the field value of<br>
                                    an entity field when that information is essential to the operation of the<br>
                                    application.<br>
                                  <h4>  Named Method</h4>
                                    This object-specific method is triggered explicitly by a call to the<br>
                                    EKG_TriggerNamedMethod API function. A named method has the capability of<br>
                                    performing multiple API functions on all fields within a particular entity. RODM<br>
                                    implicitly locks the entity while the method is running. No other method or<br>
                                    application can query or change any of the fields of the target entity until the<br>
                                    Named method returns control to RODM.<br>
                                    This method is used to perform multiple API functions on a single entity where it<br>
                                    is critical that no other method or application can query or change the entity's<br>
                                    fields.<br>
                                    <hr>
                                  <h4> Using the Method API</h4>
                                    To write methods for RODM, access to RODM data and services is required. The<br>
                                    method API provides a set of entry points to RODM that can be called by<br>
                                    methods.<br>
                                    A variety of services are available to methods. Some services are available only to<br>
                                    object-independent methods, and some are available only to object-specific<br>
                                    methods.<br>
                                    Method API calls to RODM pass the following parameters:<br>
                                    <li>Transaction information block</li>
                                  <li>Function block</li>
                                <li>Response block</li>
                                    The function block can point to additional parameters, such as an entity access<br>
                                    information block and a field access information block, which identify the target of<br>
                                    the function. The response block is required only for some functions.<br>
                                    The transaction_info_block, function_block, and response_block have the same<br>
                                    format as the blocks used by the user API. Table 36 on page 358 lists where you<br>
                                    can find more information about these blocks.</p><br>
                                    <hr>
                                    <p><i>Table 36. Additional Information About Blocks</i></p>
                                    <table border="2" cellpadding="7" cellspacing="7">
                                      <th>If You Want More Information </th><th>on See Page</th>
                                      <tr><td>Transaction_info_block </td><td>312</td></tr>
                                      <tr><td>Response_block</td><td>319</td></tr>
                                      <tr><td>Function_block</td><td>312</td></tr>
                                    </table>
                                    <p>The CALL statement from the PL/I or C language program transfers control to the<br>
                                      code segment EKGMAPI. The method must be link-edited with the EKGMAPI<br>
                                      module during the link-edit step. Figure 86 shows an example PL/I CALL<br>
                                      statement.<br>
                                      Declare EKGMAPI Entry( structure, structure, structure );<br>
                                      Call EKGMAPI( transaction_info_block,<br>
                                      function_block,<br>
                                      response_block /* Null pointer => omitted */<br>
                                      );<br>
                                     <i> Figure 86. Method API Interface Declaration and Invocation Example</i><br>
                                     <h3>Register Conventions</h3>
                                      The method code must follow this register convention:<br>
                                      Register 1<br>
                                      Points to the first of three consecutive memory locations (a parameter list)<br>
                                      that contains addresses of the transaction_info_block, function_block, and<br>
                                      response_block.<br>
                                    <b>Register 12</b><br>
                                      Is reserved for RODM runtime environment. This register must be<br>
                                      preserved by the method. For code written in PL/I and C, this register<br>
                                      requirement is consistent with the generated code.<br>
                                    <b>Register 13</b><br>
                                      Contains the address for the 72-byte save area of the calling program.<br>
                                    <b>  Register 14</b><br>
                                      Contains the return address for the calling program.<br>
                                    <b> Register 15</b><br>
                                      Contains the entry address for the EKGMAPI module.<br>
                                    <h3>Usage Notes</h3><br>
                                      The details of all RODM functions are specified in function blocks. The method<br>
                                      builds a function block and passes it to RODM to request a desired transaction.<br>
                                      The method API functions are described in Chapter 14, “Application Programming<br>
                                      Reference,” on page 371.<br>
                                      The entity_access_information data, pointed to by the function block, is interpreted<br>
                                      the same way for method API calls from object-independent methods as it is from<br>
                                      user API calls. However, class and object information is ignored if the call is made<br>
                                      from an object-specific method.<br>
                                      The object-specific change, query, notification, and named methods can only access<br>
                                      fields within the object or class from which the method API call is performed.<br>
                                     </p>
                                     <hr>
                                     <img src="27.PNG">
                                     <p><i>Figure 87. Method API Query Field Control Block Sample</i></p><br>
                                     <p>API Query Function Control Block Example<br>
                                     <h3> Method Parameters</h3><br>
                                      Many transactions have optional parameters that are either being passed to or<br>
                                      installed with methods. There are two kinds of method parameters: <br>
                                      <li>Long-lived parameters</li><br>
                                      <li>Short-lived parameters</li><br>
                                     <h4> Long-Lived Parameters</h4><br>
                                      The long-lived parameters are statically defined parameters. <br>
                                      Long-lived parameters are: <br>
                                      <li>Valid only for object-specific methods</li> <br>
                                      <li>A variable length, SelfDefining string of data</li> <br>
                                      <li>Restricted to 254 bytes</li> <br>
                                      <li>Internal meaning is user-defined and user-interpreted</li> <br>
                                      Long-lived parameters are saved in RODM with a method at the time the method <br>
                                      is assigned to a subfield, such as when a notification method is installed by the <br>
                                      EKG_AddNotifySubscription function or when a named, query, or change method <br>
                                      is assigned to a field or subfield. <br>
                                      These long-lived parameters are not immediately used, but are saved until the <br>
                                      corresponding method is run (by the appropriate triggering mechanism), and they <br>
                                      are made available to that method when the method runs. In this way, general <br>
                                      purpose methods can be written and the parameters that provide the desired <br>
                                      function specified when the method is assigned to a field or subfield.</p> <br>
                                      <hr>
                                      <p>Long-lived parameters have the form of a variable length, SelfDefining data string <br>
                                        where the length is a maximum of 254 bytes. The content of the 254 bytes of data <br>
                                        is not specified by RODM; it is determined by specification of that particular <br>
                                        method's interface. The contents of the actual SelfDefining data string cannot be <br>
                                        changed after it is specified during method assignment to a field. However, if that <br>
                                        long-lived parameter contains a reference to a field within an object, the value of <br>
                                        that field can be changed at any time. <br>
                                       <h3>Short-Lived Parameters</h3>
                                        Short-lived parameters are dynamically defined parameters. Short-lived parameters <br>
                                        have the following characteristics: <br>
                                        <li>Internal meaning is user-defined and user-interpreted for both object-specific <br>
                                        and object-independent methods when the method is run using an API request. </li> <br>
                                        <li>They are a variable length, SelfDefining string of data.</li> <br>
                                        <li>They are restricted to 254 bytes for object-specific methods.</li> <br>
                                      <li>They are restricted to 32767 bytes for object-independent methods.</li> <br>
                                        Short-lived parameters are not prestored. They are supplied through the specific <br>
                                        transaction request API and are made immediately available to methods being <br>
                                        triggered by the transaction. These parameters always have the form of a variable <br>
                                        length SelfDefining data string. <br>
                                        Short-lived parameters passed to object-independent methods through the User <br>
                                        API can be up to 32767 bytes, but short-lived parameters passed to object-specific <br>
                                        methods are restricted to 254 bytes. The meaning of these strings is not defined or <br>
                                        limited by RODM. RODM sees only a string of bytes. The requesting user <br>
                                        application and the methods being triggered must be written to agree on the <br>
                                        contents of this string of bytes. <br>
                                       <h3>Installing and Freeing Methods</h3>
                                        Before an object-specific method can be assigned to a field or subfield of an object, <br>
                                        and before an object-independent method can be run, the method must be installed <br>
                                        in RODM. To install a method, create an object of the EKG_Method class. <br>
                                        To install a named method, follow these steps: <br>
                                        1. Determine where you want to install the method. <br>
                                        For named methods, you must use a field of type MethodSpec on either a class <br>
                                        or an object. <br>
                                        2. Create an object of the EKG_Method class. <br>
                                        Creating this object returns to you the object ID of the newly created object. <br>
                                        3. Use the EKG_ChangeField, the EKG_ChangeSubfield, or <br>
                                        EKG_ChangeMultipleFields functions to set the value of the MethodSpec field <br>
                                        to the object ID and any long-lived parameters required by your method. <br>
                                        You can also install methods using the RODM load function. When you create an <br>
                                        object in the EKG_Method class, RODM loads the method into its address space. <br>
                                        Attempting to assign a method name to a field or subfield before the method has <br>
                                        been installed results in an error return code from the change transaction. <br>
                                        If an installed method needs to be changed, the EKG_Refresh field in the <br>
                                        EKG_Method class enables you to load a new copy of the method into RODM. <br>
                                        Trigger the named method specified in the EKG_Refresh field of the method object <br>
                                        you want to reload to load the new copy of the method from the librar</p>
                                        <hr>
                                        <p>When a method is no longer needed, a user can free the storage taken up by the <br>
                                          method and can purge the method's name and address from internal RODM tables <br>
                                          by executing a delete object transaction against the method object. A method can <br>
                                          only be freed if it is not assigned as a value to any field or subfield in RODM. <br>
                                          After method has been freed, it cannot be assigned to a field or subfield, and it <br>
                                          cannot be run as an object-independent method until it is re-installed. <br>
                                          While other methods need to be installed before use, the null method, NullMeth, is <br>
                                          always installed and cannot be freed. An attempt to install or free NullMeth results <br>
                                          in an error return code from RODM. Therefore, the method name NullMeth is <br>
                                          reserved in RODM, and cannot be used for a user-written method. Other methods <br>
                                          that are supplied with the NetView program must be installed before use just like <br>
                                          user-written methods. <br>
                                          Synchronous and Asynchronous Execution of Functions <br>
                                          If a method triggers a function or another method, the triggered function or <br>
                                          method runs synchronously with the triggering method. The triggering method <br>
                                          stops running and does not resume processing until the triggered function or <br>
                                          method finishes and returns. The method API provides the <br>
                                          EKG_MessageTriggeredAction function, which provides a method with the <br>
                                          capability to trigger a function or another method to run asynchronously with it. <br>
                                          The triggering method continues to run while the triggered function or method <br>
                                          starts, processes, and finishes. <br>
                                          Although the EKG_MessageTriggeredAction function is intended to allow an <br>
                                          object-specific method to access entities in the RODM data cache other than the <br>
                                          one it is associated with, it can also be called by an object-independent method. <br>
                                          Also, the EKG_MessageTriggeredAction function enables the following functions to <br>
                                          run asynchronously with the triggering method:  <br>
                                          <li>Change or swap the contents of a field or subfield</li> <br>
                                        <li> Link or unlink two objects</li> <br>
                                          <li> Revert inheritance of a field</li> <br>
                                          <li> Create and delete objects</li> <br>
                                          <hr>
                                        <h3> Method Anchor Service</h3>
                                          RODM provides a callable method anchor service that will return a pointer to an<br>
                                          8-byte work area. This area is cleared to zeros prior to invoking the method, and<br>
                                          the contents of the area is preserved when the method causes other methods to be<br>
                                          triggered.<br>
                                          It is intended that this area be used for communication between the component<br>
                                          modules of large, complex methods. Note that it cannot be used to communicate<br>
                                          between methods, because it is cleared by RODM each time a method is run.<br>
                                          Run the EKGMANC service routine using the following code for PL/I:<br>
                                          DCL WORK_AREA CHAR(8) BASED(WORK_AREA_PTR);<br>
                                          DCL WORK_AREA_PTR POINTER;<br>
                                          CALL EKGMANC(WORK_AREA_PTR);<br>
                                          For C use the following code:<br>
                                          char *work_area_ptr;<br>
                                          EKGMANC(&work_area_ptr);</p>
<hr>
<p>There is no return or reason code from the EKGMANC call. The address of the<br>
  work area is always returned.<br>
  <hr>
  <h3>Coding Your RODM Method</h3>
  The following sections describe some of the details of writing your own methods.<br>
  These sections include information about compiler options, link-editing, and<br>
  restrictions. Be sure to review both the general restrictions and the restrictions for<br>
  the programming language you are using.<br>
  <h4>Installation Written Methods</h4>
  Installation written methods can be written in PL/I or in C. These methods can use<br>
  the multicultural support of the PL/I language. DBCS character strings can be<br>
  manipulated as graphic constants.<br>
  Installation supplied methods can reference RODM data stored in either SBCS or<br>
  DBCS formats.<br>
  After your method has been coded, you can run the method using test data and<br>
  debugging aids to find any syntax or logic errors. Refer to the IBM Tivoli NetView<br>
  for z/OS Programming: PL/I and C for additional information. Install your method by<br>
  link-editing it to the appropriate user library pointed to by the STEPLIB DD<br>
  statement in your start up JCL for RODM.<br>
  <h4>NetView Methods</h4>
  The NetView program includes a basic set of RODM methods. You can write your<br>
  own methods in either PL/I or C. You can supplement or replace methods that are<br>
  supplied with the NetView program with your methods. All methods that are<br>
  supplied with the NetView program reside in the CNMLINK target library for the<br>
  NetView program.<br>
  Note: Enterprise PL/I for z/OS cannot be used to compile method code, including<br>
  your method code and method code that is supplied with the NetView program.<br>
  Currently, the following methods are supplied with RODM:<br>
 <b>EKGNOTF</b><br>
  Notify for any change<br>
<b>EKGNLST</b><br>
  Notify if changed value is equal to one value in a list of values<br>
 <b>EKGNEQL</b><br>
  Notify if changed value is equal to a specific value<br>
 <b>EKGNTHD</b><br>
  Notify if changed value is within a specified threshold<br>
  <b>EKGCTIM</b> <br>
  Change method to trigger an Object-independent method to complete an<br>
  action asynchronously<br>
 <b>EKGMIMV</b><br>
  Named method to increment a value<br>
  <b>EKGSPPI</b><br>
  Object-independent method used by the RODM automation platform</p>
  <hr>
  <p>All notification methods return, in the notification block, the current value,<br>
    previous value, and time stamp (if these subfields are defined) from the field that<br>
    is causing the notification message.<br>
    The methods that are supplied with the NetView program for RODM are described<br>
    in the following sections on a functional basis. All parameters that are passed to<br>
    methods are specified as SelfDefining data strings.<br>
   <h3> Programming Language Specific Preprocessor Statements</h3><br>
    When compiling your program or linking your source code, add the following<br>
    preprocessor statements.<br>
   <h4> Compiling IBM C Methods</h4><br>
    If you are compiling your methods using the IBM C language, follow these<br>
    guidelines:<br>
     <li> Code the following pragma statement:</li><br>
    #pragma linkage(csect,PLI)<br>
    where csect is the name of the external entry-point csect.<br>
     <li>If any RODM control blocks are referenced in the modules, include file<br>
    EKG3CINC.H in your source file. This file includes all of the RODM function<br>
    and response blocks, and the function prototype statements for the RODM entry<br>
    points EKGMANC, EKGUAPI, EKGMAPI, and EKGWAIT.</li><br>
     <li>If no RODM control blocks are referenced in the modules but the modules do<br>
    call EKGMANC, EKGUAPI, EKGMAPI, or EKGWAIT, include file EKG3CEEP.H<br>
    in your source file.</li><br>
     <li> Do not specify the RENT option when compiling.</li><br>
    The following is an example of IBM C source for coding a method:<br>
    #pragma linkage(thisproc,PLI)<br>
    #include "EKG3CINC.H"<br>
    /* or */<br>
    #include "EKG3CEEP.H"<br>
    void thismethod(void arg)<br>
    {<br>
    /* code */<br>
    }<br>
   <h4> Compiling IBM PL/I Methods</h4><br>
    If you are compiling your methods using the IBM PL/I language, follow these<br>
    guidelines:<br>
     <li> If any RODM control blocks are referenced in the modules, include file<br>
    EKG1IINC in your source file. This file includes all of the RODM function and<br>
    response blocks, and the function prototype statements for the RODM entry<br>
    points EKGMANC, EKGUAPI, EKGMAPI, and EKGWAIT.</li><br>
     <li>If no RODM control blocks are referenced in the modules but the modules do<br>
    call EKGMANC or EKGMAPI, include file EKG1IEEP in your source file. </li><br>
    <li> Specify the REENTRANT option when compiling.</li><br>
     <li>Specify the MACRO preprocessor compiler option if you include RODM macros<br>
    in your method.</li><br>
    The following is an example of IBM PL/I source for coding a method:</p>
    <hr>
    <p>*PROCESS MACRO;<br>
      thismethod: proc;<br>
      %include ekglib(EKG1IINC);<br>
      or<br>
      %include ekglib(EKG1IEEP);<br>
      /* code */<br>
      end thismethod;<br>
    <h4>Linking Methods that Call EKGMAPI Directly</h4>
      Specify the following link-edit control statements when linking a method that calls<br>
      EKGMAPI directly:<br>
      <method object code><br>
      INCLUDE SYSLIB(EKGMAPI)<br>
      ENTRY method_name<br>
      NAME method_name(R)<br>
      Specify these link-edit options:<br>
       <li>AMODE=31</li><br>
      <li> RMODE=ANY or RMODE=24</li><br>
      <li>RENT</li><br>
     <h4> Restrictions on Methods</h4>
      All RODM methods must run in PSW key 8, which is the default. Do not change<br>
      the PSW key in any method.<br>
      <h4>PL/I Language Restrictions</h4>
      Installation defined methods written in PL/I require a PL/I compiler that is<br>
      supported by RODM. These PL/I programs are expected to clean up after<br>
      execution is complete for a particular invocation; all dynamically allocated storage<br>
      is freed. In addition, PL/I programs that run in the RODM address space must<br>
      observe certain the following restrictions:<br>
      <li>Use of PLITEST</li><br>
      The PLITEST facility is not available to programs running in the RODM address<br>
      space.<br>
      <li>Use of FETCH and RELEASE</li><br>
      PL/I procedures cannot be fetched or released by other PL/I procedures. The<br>
      user API supports adding and deleting methods. These services can be used in<br>
      place of FETCH and RELEASE.<br>
      <li>Use of DATE built-in function</li><br>
      The PL/I DATE built-in function cannot be called by a program running in the<br>
      RODM address space. <br>
    <li>Use of TIME built-in function</li><br>
      The PL/I TIME built-in function cannot be called by a program running in the<br>
      RODM address space. <br>
      <li>Use of file I/O</li><br>
      PL/I file I/O cannot be used by programs running in the RODM address space.<br>
      No RODM method attempts to access SYSPRINT. However, the RODM output<br>
      to log function can be used for file I/O. <br>
      <li>Interlanguage communication</li></p>
      <hr>
      <p>Interlanguage calls to COBOL and FORTRAN routines cannot be used. Only<br>
        interlanguage calls to C and assembler are permitted. <br>
        <li>Delays</li><br>
        The execution of a method cannot be suspended. Methods complete as soon as<br>
        possible.<br>
         <li> Wait</li><br>
        The execution of a method cannot be suspended.<br>
        <li>Use of PL/I DISPLAY statement</li><br>
        The PL/I DISPLAY statement writes its output to the RODM type-1 log record.<br>
        Because of performance and logging impacts, the PL/I DISPLAY statement is not<br>
        usually used. Instead, use the EKG_OutputToLog API function.<br>
        <li>Use of PL/I multitasking</li><br>
        The PL/I multitasking facilities cannot used. Task management is handled by<br>
        RODM facilities and not the PL/I facilities. The task, event, and priority options<br>
        of the CALL statement cannot be used, and do not use the COMPLETION,<br>
        STATUS, and PRIORITY built-in functions.<br>
        <li>Use of MAIN option</li><br>
        User methods cannot be coded with the PL/I MAIN option of the PROCEDURE<br>
        statement. <br>
        <li>Linkage field</li><br>
        All methods must be reentrant. In addition to writing reentrant code, the<br>
        REENTRANT option of the PROCEDURE statement must be used.<br>
        <li>Cannot use controlled storage variables, or anything using pseudo-register<br>
        vectors, such as file I/O and fetch/release</li><br>
        <li>Programs must not request CHECKPOINT, SORT, or PLIDUMP</li><br>
        <li>PL/I options for CHECK and FLOW must not be used</li><br>
        <li>Use of On-Units and Signal</li><br>
         – PL/I programs cannot perform attention handling; that On-unit will not get<br>
        control<br>
         – PL/I programs must not signal ERROR or FINISH<br>
        – PL/I programs must not contain On-error or On-finish statements<br>
       <h3> C Language Restrictions</h3>
        Methods must be compiled using the NORENT option. Methods must not be<br>
        prelinked using the C prelink facility.<br>
         The following C functions cannot be used in RODM methods: <br>
        <li>Atexit()</li><br>
        <li>Exit()</li><br>
        <li> Main()</li><br>
        <li>All file and stream input/output statements and library functions<br>
        Do not specify the static storage class specifier for any data in a method.<br>
        The RODM output to log function can be used for file input/output.<br>
       <h3> Restrictions in General</h3></li><br>
        An object-specific method can query and manipulate only the object or class with<br>
        which the method is associated.</p>
        <hr>
        <p>The following are restrictions on methods: <br>
          <li> Named methods</li><br>
          Named methods can be run to run synchronously with the caller directly from<br>
          the user API, by an object-independent method through the method API, or by a<br>
          named method through the method API. Also, named methods can be triggered<br>
          to run asynchronous to the caller through the message interface provided in the<br>
          method API.<br>
          Named methods cannot be triggered for asynchronous execution through the<br>
          user API.<br>
          <li>Object-independent methods</li><br>
          Object-independent methods can be run to run synchronously with the caller<br>
          from the user API or the method API. Also, they can be triggered from any<br>
          method, through the message interface provided in the method API, to run<br>
          asynchronous to that method.<br>
          Object-independent methods cannot be triggered for asynchronous execution<br>
          through the user API.<br>
          <li>Change methods</li><br>
          Change methods cannot be used on system-defined fields. See “System-Defined<br>
          Fields” on page 207 for a complete list of these fields.<br>
          Change methods used on LINK fields, that is the fields of data type ObjectLink<br>
          or ObjectLinkList, are triggered by EKG_LinkTrigger and EKG_UnlinkTrigger<br>
          functions. These change methods have the following restrictions:<br>
           – They cannot change fields.<br>
            – They cannot perform a link or unlink function.<br>
             – They must set a return code if the return code is non-zero. <br>
             - A zero return code allows the link or unlink to continue. <br>
             - A non-zero return code prohibits the link or unlink.<br>
              - If the change methods exist, the return codes from the change methods<br>
          defined to both objects must be zero in order for the link or unlink to<br>
          continue.<br>
           <li> Notification methods</li><br>
          A particular combination of a User_appl_ID, notification method, SubscribeID,<br>
          and long-lived parameters uniquely specify a notification method and can be<br>
          assigned only one time to a particular notification subfield.<br>
           <li> All methods </li><br>
           – All methods must be written as reentrant.<br>
            – Methods cannot query a notification queue or suspend their own execution.<br>
             – When RODM is operating on a z/OS system, methods must adhere to<br>
          operating system constraints placed on applications running in cross-memory<br>
          mode; for example, the methods must not use any service that requires the<br>
          execution of an IBM z/Architecture® SVC instruction. <br>
          – If a method uses recovery routines such as ESTAE, ESTAX, SPIE, or STAE,<br>
          the recovery routines must be set up to percolate so that RODM regains<br>
          control after any abend.<br>
           – Use of the method API to synchronously run another method must not cause<br>
          recursive execution of any previously run method. <br>
          – The response block overflow buffer is not available to methods. If the<br>
          response block supplied by a method is too small for the data returned by the<br>
          function, the data that does not fit in the supplied response block is<br>
          discarded.</p>
          <hr>
          <p><h3>RODM Method Services</h3>
            Some RODM functions can be used by all types of methods; others can be used<br>
            only by certain types of methods. The following sections lists the types of methods<br>
            and the RODM functions that each can use.<br>
          <h3>Services Available to both Object-Specific and<br>
            Object-Independent Methods</h3><br>
            When you design your program, you can implement the following functions,<br>
            available for use in both object-independent and object-specific methods. <br>
            <li>Querying RODM Data</li><br>
            – EKG_QueryField (See “EKG_QueryField - Query a Field” on page 416) <br>
            – EKG_QueryMultipleSubfields (See “EKG_QueryMultipleSubfields - Query<br>
            Multiple Value Subfields” on page 424) <br>
            – EKG_QuerySubfield (See “EKG_QuerySubfield - Query a Subfield” on page<br>
            432) <br>
            – EKG_QueryEntityStructure (See “EKG_QueryEntityStructure - Query<br>
            Structure of an Entity” on page 415) <br>
            – EKG_QueryFieldStructure (See “EKG_QueryFieldStructure - Query Structure<br>
            of a Field” on page 421)<br>
            – EKG_QueryFieldID (See “EKG_QueryFieldID - Query Field Identifier” on<br>
            page 418) <br>
            – EKG_QueryFieldName (See “EKG_QueryFieldName - Query a Field Name”<br>
            on page 419)<br>
            <li>Actions against RODM Data</li><br>
            – EKG_ChangeField (See “EKG_ChangeField - Change a Field” on page 380) <br>
            – EKG_ChangeMultipleFields (See “EKG_ChangeMultipleFields - Change<br>
            Multiple Fields” on page 381)<br>
            – EKG_ChangeSubfield (See “EKG_ChangeSubfield - Change a Subfield” on<br>
            page 383) <br>
            – EKG_RevertToInherited (See “EKG_RevertToInherited - Revert to Inherited<br>
            Value” on page 435) <br>
            – EKG_AddNotifySubscription (See “EKG_AddNotifySubscription - Add<br>
            Notification Subscription” on page 377) <br>
            – EKG_DeleteNotifySubscription (See “EKG_DeleteNotifySubscription - Delete<br>
            Notification Subscription” on page 398) <br>
            – EKG_TriggerNamedMethod (See “EKG_TriggerNamedMethod - Trigger a<br>
            Named Method” on page 445)<br>
            <li>Additional Method Support </li><br>
            – EKG_SendNotification<br>
            – EKG_MessageTriggeredAction<br>
            – EKG_SetReturnCode <br>
            – EKG_OutputToLog<br>
            – EKG_ResponseBlock (can be used in named and query object-specific<br>
            methods and object-independent methods) <br>
            – EKG_QueryFunctionBlockContents<br>
            This list of query and action functions is a subset of the transactions available to<br>
            RODM users through the user API.</p>
            <hr>
            <p>Both the user API and method API use the same function blocks to specify the<br>
              function requested for queries and actions with the queries generating responses<br>
              that are returned in response blocks. Also, a named method can generate data that<br>
              is returned in a response block.<br>
              See Chapter 11, “Writing Applications that Use RODM,” on page 305 for the<br>
              formats for all these function blocks and response blocks. As in the user API, the<br>
              user of the method API is responsible for allocating and freeing the storage in<br>
              which function and response blocks reside. The method API function blocks for the<br>
              additional method support functions are described in this section.<br>
              <h3>Other Services Available to Object-Independent Methods</h3>
              The following additional services are available to object-independent methods<br>
              through the method API and the user API.<br>
              <li>EKG_LinkNoTrigger, EKG_LinkTrigger (See “EKG_LinkNoTrigger, </li><br>
               EKG_LinkTrigger - Link Two Objects” on page 407)<br>
              <li>EKG_UnlinkNoTrigger, EKG_UnlinkTrigger (See “EKG_UnlinkNoTrigger,<br>
               EKG_UnlinkTrigger - Unlink Two Objects” on page 448)</li><br>
              <li>EKG_CreateObject (See “EKG_CreateObject - Create an Object” on page 393)</li><br>
              <li>EKG_DeleteObject (See “EKG_CreateObject - Create an Object” on page 393)</li><br>
              <li>EKG_TriggerOIMethod (See “EKG_TriggerOIMethod - Trigger an<br>
              Object-Independent Method” on page 447)</li><br>
              <h3>Other Services Available to Object-Specific Methods</h3><br>
              The following additional services are available only to object-specific methods:<br>
              <li>EKG_WhereAmI</li><br>
              <li>EKG_QueryObjectName</li><br>
             <h3>Services Available to the Initialization Method</h3>
              The initialization method is the only method that can use the following functions.<br>
              The method can run these functions at RODM initialization time to create the<br>
              RODM data structure and load the data into the RODM data cache.<br>
              <li>Administrative functions </li><br>
              – EKG_CreateClass (See “EKG_CreateClass - Create a Class” on page 390) <br>
              – EKG_CreateField (See “EKG_CreateField - Create a Field” on page 391)<br>
              – EKG_CreateSubfield (See “EKG_CreateSubfield - Create a Subfield” on page<br>
              394)<br>
              <li>Control functions </li>
              – EKG_Checkpoint (See “EKG_Checkpoint - Checkpoint RODM to DASD” on<br>
              page 384)<br>
              The access to the above mentioned functions is similar to the access available<br>
              through the user API. These functions are run by calls to RODM using the method<br>
              API. Use of these functions requires the standard function block definitions.<br>
              The method API functions and interfaces available to the initialization method also<br>
              include all those enabled in object-independent methods, with the following<br>
              exceptions. Do not use these exceptions within the initialization method.<br>
              <li>EKG_SendNotification</li><br>
              – This function fails because no Notification_queues can be registered at the<br>
              time the initialization method is running.</p>
              <hr>
              <p><li>EKG_ResponseBlock</li><br>
                – No response block is passed to the initialization method, so the data is lost.<br>
                 <li>EKG_QueryFunctionBlockContents </li><br>
                 – No function block is used to initiate the initialization method execution, so no<br>
                data is available.<br>
                 <li>EKG_CreateObject to create an EKG_NotificationQueue object </li><br>
                 – Notification queues are named by concatenating a User_appl_ID to the queue<br>
                name. This function always fails for the initialization method because no<br>
                User_appl_ID is available during initialization.<br>
                If the initialization method uses the message interface to start an asynchronous<br>
                task, RODM initialization continues without waiting for the completion of that<br>
                asynchronous task.<br>
              <h3> RODM Method Library</h3>
                To access the method API services, RODM provides a library that contains entry<br>
                points for method API services. This library is called the RODM Method Library<br>
                and is given the default name CNMLINK.<br>
                This library is especially intended for use with C and PL/I programs. To access a<br>
                service such as EKGMAPI, declare EKGMAPI as an external entry in your<br>
                program. To resolve the external name, use the CNMLINK library. <br>
                Member EKGMIMV of data set CNMSAMP in the sample library contains an<br>
                example showing how EKGMAPI can be called from a named method to<br>
                increment the value of a specified field by the value of a field.</p>
                <hr>
                <p><h3>Chapter 14. Application Programming Reference</h3>
                  The details of all transactions against RODM data are specified in function blocks.<br>
                  A user builds a function block and passes it to RODM to request a desired<br>
                  transaction. All function blocks contain a Function_ID which specifies the function<br>
                  being requested from RODM.<br>
                  <hr>
                <h3>Summarizing RODM Functions</h3>
                  This chapter describes each of the RODM functions. The major categories of<br>
                  functions follow: v Access functions<br>
                  <li> Control functions</li><br>
                  <li>Administrative functions</li><br>
                  <li>Action functions</li><br>
                  <li>Query functions</li><br>
                  <li>RODM user API services</li><br>
                  <li>RODM method API services</li><br>
                  See Chapter 11, “Writing Applications that Use RODM,” on page 305 for an<br>
                  explanation of how function blocks are used in application programs. See<br>
                  Chapter 13, “Writing RODM Methods,” on page 343 for an explanation of how<br>
                  function blocks are used in methods.<br>
                <h3>Access Functions</h3>
                  Access functions enable a user application program to connect to and disconnect<br>
                  from RODM.<br>
                 <b>EKG_Connect or EKG_ConnectLong: Connect to RODM</b><br>
                  The connect function is called to connect the user to RODM.<br>
                 <b>EKG_Disconnect: Disconnect from RODM</b><br>
                  The disconnect function is called to end the connection between the user<br>
                  and RODM.<br>
                 <h3>Control Functions</h3><br>
                  Control functions allow a user application program that has the appropriate access<br>
                  level to checkpoint RODM data to DASD or to stop RODM, with or without<br>
                  checkpointing data.<br>
                  <b>EKG_Checkpoint: Checkpoint RODM</b><br>
                  Checkpoint RODM data to DASD.<br>
                 <b>EKG_Stop: Stop RODM</b><br>
                  Stop the RODM subsystem.<br>
                  <h3>Administrative Functions</h3>
                  Use the RODM administrative functions, with the appropriate function blocks<br>
                  passed as parameters, to delete or create classes, fields, and subfields. Because<br>
                  response blocks are not needed in administrative calls, set the response block<br>
                  pointer to null.</p>
                  <hr>
                  <p>When a RODM class is initially created, it contains the system-defined fields and<br>
                    the public fields of its primary parent. The values of these fields are inherited from<br>
                    their primary parent. Classes are differentiated from their parent by the existence<br>
                    of additional fields or by setting different values in the fields that do exist. Most<br>
                    frequently, a child class needs to have more fields than exist on the parent. These<br>
                    additional fields must be explicitly added to the class. RODM has no set limit of<br>
                    the number of fields a class can contain.<br>
                    You can add a field to a class. You can add a subfield only to a field that is already<br>
                    in place. You cannot add a field directly to an object.<br>
                   <b> EKG_CreateClass: Create a Class</b><br>
                    Create a new class in the RODM data cache.<br>
                  <b> EKG_CreateField: Create a Field</b><br>
                    Add a new field to a class.<br>
                  <b>EKG_CreateSubfield: Create a Subfield</b><br>
                    Add a new subfield to a field in a class.<br>
                  <b> EKG_DeleteClass: Delete a Class</b><br>
                    Remove a class from the RODM data cache.<br>
                  <b>EKG_DeleteField: Delete a Field</b><br>
                    Delete a field from a class.<br>
                   <b>EKG_DeleteSubfield: Delete a Subfield</b><br>
                    Delete a subfield from a field in a class.<br>
                   <h4>Action Functions</h4><br>
                    Action functions change values, create and delete objects and links between<br>
                    objects, add and delete notification subscriptions, and trigger named and<br>
                    object-independent methods. Action functions can be submitted in list form using<br>
                    the EKG_ExecuteFunctionList function to enable multiple actions with a single<br>
                    interface call.<br>
                  <b>EKG_AddNotifySubscription: Add a Notification Subscription</b><br>
                    Subscribe to a field.<br>
                   <b> EKG_AddObjDelSubs: Add an Object Deletion Subscription</b><br>
                    Subscribe to an object for notification of deletion.<br>
                   <b> EKG_ChangeField: Change a Field</b><br>
                    Change the value of a field.<br>
                  <b>EKG_ChangeMultipleFields: Change Multiple Fields</b><br>
                    Change the value of multiple fields of an object.<br>
                    <b>EKG_ChangeSubfield: Change a Subfield</b><br>
                    Change the value of a subfield.<br>
                  <b>EKG_CreateObject: Create an Object</b><br>
                    Create an object in the RODM data cache.<br>
                  <b>EKG_DeleteNotifySubscription: Delete a Notification Subscription</b><br>
                    Delete a subscription to a field.<br>
                  <b> EKG_DeleteObject: Delete an Object</b><br>
                    Delete an object in the RODM data cache.<br>
                  <b>EKG_DelObjDelSubs: Delete an Object Deletion Subscription</b><br>
                    Delete a subscription to an object.</p><br>
                    <hr>
                    <p><b>EKG_LinkNoTrigger: Link Two Objects</b><br>
                      Link two objects; do not run notify methods.<br>
                    <b>EKG_LinkTrigger: Link Two Objects</b><br>
                      Link two objects; run notify methods.<br>
                    <b>EKG_RevertToInherited: Revert to Inherited Value</b><br>
                      Remove the local copy of the data value from a field and replace it with<br>
                      the inherited value.<br>
                     <b> EKG_SwapField: Swap a Field</b><br>
                      Compare and swap field data with new data.<br>
                    <b>EKG_SwapSubfield: Swap a Subfield</b><br>
                      Compare and swap subfield data with new data.<br>
                     <b> EKG_TriggerNamedMethod: Trigger a Named Method</b><br>
                      Run a named method.<br>
                     <b> EKG_TriggerOIMethod: Trigger an Object-Independent Method</b><br>
                      Run an object independent method.<br>
                     <b> EKG_UnlinkNoTrigger: Unlink Two Objects</b><br>
                      Unlink two objects; do not run notify methods.<br>
                    <b>  EKG_UnlinkTrigger: Unlink Two Objects</b><br>
                      Unlink two objects; run notify methods.<br>
                      <h4>Query Functions</h4>
                      Query functions enable a user application program to query the values contained<br>
                      in fields, subfields, notification queues, and access blocks. Query functions can be<br>
                      submitted in list form using the EKG_ExecuteFunctionList function to enable<br>
                      multiple actions with a single interface call.<br>
                      The contents of the field or information to be queried is returned in the response<br>
                      block.<br>
                      If a field of an object or class is being queried and there is a query method<br>
                      associated with the field, that query method is run before the contents of the field<br>
                      is retrieved. That method has the opportunity to change the contents of the field<br>
                      before the data in the field is read and returned to the caller. A query method can<br>
                      explicitly set the returned value of the query operation by using the<br>
                      EKG_ResponseBlock function. If a query method uses the EKG_ResponseBlock<br>
                      function, RODM does not place any data into the response block.<br>
                     <b>EKG_Locate: Locate Objects Using Public Indexed Field</b><br>
                      Provide a list of all objects in RODM that match a specified search criteria.<br>
                     <b> EKG_QueryEntityStructure: Query Structure of an Entity</b><br>
                      Provide a list of all fields within a class or object, specifying each field's<br>
                      name, data type, and inheritance state.<br>
                     <b> EKG_QueryField: Query Field</b><br>
                      Obtain the value of a field.<br>
                     <b>EKG_QueryFieldID: Query Field Identifier</b><br>
                      Convert a field name to its field identifier.<br>
                      <b>EKG_QueryFieldName: Query Field Name</b><br>
                      Convert a field identifier to its field name.</p>
                      <hr>
                      <p><b>EKG_QueryFieldStructure: Query Structure of a Field</b><br>
                        Provide organization of a field (that is, data type, local copy indicator, and<br>
                        subfield map).<br>
                       <b>EKG_QueryMultipleSubfields: Query Multiple Value Subfields</b><br>
                        Obtain the value of multiple subfields for an object.<br>
                      <b>EKG_QueryNotifyQueue: Query Notification Queue</b><br>
                        Obtain next queue element, if available.<br>
                      <b> EKG_QueryResponseBlockOverflow : Query Response Block Overflow</b><br>
                        Obtains any overflow response block data.<br>
                      <b> EKG_QuerySubfield: Query Subfield</b><br>
                        Obtain the value of a subfield.<br>
                       <h3> RODM User API Services</h3><br>
                       <b>EKG_ExecuteFunctionList: Execute a List of Functions</b><br>
                        Enable user application programs to pass a list of RODM functions in a<br>
                        single function call.<br>
                        <h4>RODM Method API Services</h4><br>
                       <b> EKG_LockObjectList: Lock List of Objects</b><br>
                        This API was used to enable object-independent methods to explicitly lock<br>
                        objects. It is no longer necessary, but is maintained for compatibility. <br>
                     <b> EKG_MessageTriggeredAction: Trigger an Action by a Message</b><br>
                        Provide object-specific methods with the ability to trigger an asynchronous<br>
                        API function for another object or class.<br>
                       <b>EKG_QueryFunctionBlockContents: Query Function Block Contents</b><br>
                        Provide methods with the contents of the function block of the function<br>
                        request that triggered the method.<br>
                       <b> EKG_QueryObjectName: Query Object Name</b><br>
                        Allow an object-specific method to convert an ObjectID to the<br>
                        corresponding object name.<br>
                       <b>EKG_OutputToLog: Output to Log</b><br>
                        Provide the ability to output information to the RODM log.<br>
                      <b> EKG_ResponseBlock: Output to Response Block</b><br>
                        Appends method-defined information to the caller's response block, except<br>
                        for Query methods, which overwrite the response block.<br>
                      <b>EKG_SendNotification: Send a Notification</b><br>
                        Provide the facility for notification methods to send notification<br>
                        information blocks to notification queues when a field is changed.<br>
                      <b> EKG_SetReturnCode: Set Return and Reason Codes</b><br>
                        Enable a method to set the return code and reason code for the method<br>
                        caller.<br>
                        <b>EKG_UnlockAll: Unlock all Held Entities</b><br>
                        This method was used to free all locks held. It is no longer necessary, but<br>
                        is maintained for compatibility. <br>
                       <b> EKG_WhereAmI: Where Am I</b><br>
                        Enable an object-specific method to determine the class, object, and field<br>
                        for which it was triggered.</p>
                        <hr>
                        <p><h3>Function Reference</h3>
                          This section describes each of the functions available from the RODM user<br>
                          application programming interface and the RODM method application<br>
                          programming interface. The format of this section is described in “Function<br>
                          Reference Format.” The functions are listed in alphabetical order by function name.<br>
                         <h4> Function Reference Format</h4><br>
                          This section describes the format of the RODM function descriptions contained in<br>
                          this chapter. The functions are listed in alphabetical order by function name.<br>
                          Following each function name is a function description. Each function description<br>
                          contains the following reference sections:<br>
                           <li>Purpose</li><br>
                          <li>Function block format</li><br>
                          <li>Examples</li><br>
                          <li>Summary</li><br>
                          <li>Usage</li><br>
                          These reference sections are described in the following sections.<br>
                         <h4> Purpose</h4>
                          The purpose section of each function description explains what the function does.<br>
                         <h4> Function block format</h4>
                          The function block format describes the function block that you need to pass to the<br>
                          function. If the function returns a response block, the response block is also<br>
                          described in this section.<br>
                          The function block format table contains five columns:<br>
                        <b> Offset </b>The offset in decimal bytes to the beginning of the parameter. <br>
                        <b>Length</b><br>
                          The length in decimal bytes of the parameter. If the length of a parameter<br>
                          is variable, the length column contains a dash (—) character. <br>
                        <b> Type </b>The RODM abstract data type of the parameter. A few parameters do not<br>
                          use the defined RODM abstract data types. The PL/I or data types are<br>
                          listed for parameters which do not use RODM abstract data types.<br>
                         <b>Use</b> The use is either In for data input to the function, or Out for data output<br>
                          by the function. For reserved fields and fields not used by a particular<br>
                          function, the use column contains a dash (—).<br>
                         <b>Parameter Name</b><br>
                          The name of the parameter. Each parameter is described in “Function<br>
                          Parameter Descriptions” on page 452. This is the actual name used in the<br>
                          example function block or response block supplied with RODM.<br>
                        <h5>Examples</h5>
                          The examples section lists the names of the code examples provided by RODM for<br>
                          each function. Provided in both PL/I and C, these examples are on the samples<br>
                          tape that was shipped with the NetView product. Include the example function<br>
                          block and response block in your user application or method for each function you<br>
                          plan to use. Use the parameter names that are provided to access the function. This<br>
                          will limit the impact to your program of any service that might be applied to<br>
                          RODM.</p>
                          <hr>
                          <p>The example function blocks and example response blocks for PL/I contain the<br>
                            preprocessor macro substitution variable EKG_Boundary. This variable is converted<br>
                            to UNALIGNED BASED(*), which is required for PL/I programs.<br>
                            The usage coding examples are pieces of actual code that illustrate how to set up<br>
                            and call each function. Use the usage coding examples to learn about calling the<br>
                            function. Note, however, that these examples might not be suitable for inclusion in<br>
                            your programs.<br>
                            The names in the examples table are the member names of each example. The<br>
                            default data set name for function block samples and response block samples is<br>
                            NETVIEW.V6R2M1.SCNMMAC1. The default data set name for usage coding<br>
                            examples is NETVIEW.V6R2M1.CNMSAMP. For example, the complete name of<br>
                            the function block example in PL/I for the EKG_Connect function is<br>
                            NETVIEW.V6R2M1.SCNMMAC1(EKG11101). The complete name of the PL/I usage<br>
                            coding example for this function is NETVIEW.V6R2M1.CNMSAMP(EKG51101).<br>
                          <h5>Summary</h5>
                            The summary table lists the following topics for each function:<br>
                          <b>Function ID</b>
                            The function identifier used by RODM to determine which function has<br>
                            been requested.<br>
                          <b> Type </b>The type of function, such as access or query.<br>
                          <b>User API</b>
                            Specifies whether this function can be used by user applications.<br>
                          <b> Object-specific method</b>
                            Specifies whether this function can be used by object-specific methods.<br>
                           <b>Object-independent method</b>
                            Specifies whether this function can be used by object-independent<br>
                            methods.
                           <b> Initialization method</b>
                            Specifies whether this function can be used by initialization methods.<br>
                            <b>Methods triggered</b>
                            Specifies whether this function triggers query, change, or notification<br>
                            methods and which methods are triggered.<br>
                           <b>Triggered by EKG_MessageTriggeredAction</b>
                            Specifies whether this function can be run asynchronously by the<br>
                            EKG_MessageTriggeredAction function.<br>
                           <b> Authorization</b>
                            Specifies the minimum authorization level that a user application must be<br>
                            assigned in order to use this function.<br>
                            User applications must be authorized to use specific RODM functions.<br>
                            Each function specifies the required authorization level. Applications can<br>
                            use all functions with a required authorization level equal to or less than<br>
                            the authorization level of the application. Each application's authorization<br>
                            level is specified when the application User_appl_ID is created in the<br>
                            security system profile. See the IBM Tivoli NetView for z/OS Security<br>
                            Reference for information about defining authorization levels.<br>
                          <h5> Usage Notes</h5>
                            This topic provides additional function information and limitations.</p>
                            <hr>
                            <p>The parameters used by each function are described in “Function Parameter<br>
                              Descriptions” on page 452. This section describes in general what each parameter<br>
                              does. Function-specific differences in parameters, such as maximum data length,<br>
                              are listed in the usage section for the specific function.<br>
                              The return codes and associated reason codes issued by RODM functions are listed<br>
                              in “RODM Return and Reason Codes” on page 459. This section also includes cross<br>
                              reference tables that list all of the reason codes that each function uses and all of<br>
                              the functions that use a particular reason code. You can use this information to<br>
                              design the error handling routines for your user applications and methods.<br>
                              The final section in this chapter describes the methods that are supplied with the<br>
                              NetView program. These include notification and change methods you can use<br>
                              with RODM. “Supplied Methods” on page 488 describes each method and the<br>
                              parameters you pass to it.<br>
                             <h3>EKG_AddNotifySubscription - Add Notification Subscription<br>
                              Purpose</h3>
                              This function adds a notification method to a field on an object or a class. RODM<br>
                              places the notification method in a subscription list associated with the field. If the<br>
                              specified notification queue does not exist, RODM creates the notification queue<br>
                              using the specified User_appl_ID.<br>
                             <b> Function Block Format</b>
                            <i>Table 37. Function Block for the EKG_AddNotifySubscription Function</i></p>
                            <table border="2" cellpadding="7" cellspacing="7">
                              <th>Offset</th><th> Length</th><th> Type</th><th> Use</th><th> Parameter Name</th>
                              <tr><td>000</td><td>4</td><td> Integer </td><td>In </td><td>Function_ID</td></tr>
                              <tr><td>004 </td>4 <td>Pointer </td><td>In</td><td> Entity_access_info_ptr</td></tr>
                              <tr><td>008</td><td> 4</td><td> Pointer</td><td> In</td><td>Field_access_info_ptr</td></tr>
                              <tr><td>012</td><td> 8 </td><td>ApplicationID </td><td>In</td><td> User_appl_ID</td></tr>
                              <tr><td>020 </td><td>8</td><td> SubscribeID</td><td> In</td><td> Notification_queue</td></tr>
                              <tr><td>028 </td><td>8 </td><td>Anonymous(8)</td><td> In </td><td>User_word</td></tr>
                              <tr><td>036</td><td>8 </td><td>ObjectID</td><td> In</td><td> Notify_method</td></tr>
                              <tr><td>044</td><td> 4</td><td> SelfDefiningDataPtr</td><td> In</td><td>Long_lived_parm</td></tr>
                            </table>
                            <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                              parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                              information about the abstract data types listed.<br>
                             <b> Examples</b>
                            <i>Table 38. Example Names for the EKG_AddNotifySubscription Function</i></p>
                            <table border="2" cellpadding="7" cellspacing="7">
                              <th>Example</th><th> Name</th>
                              <tr><td>PL/I function block </td><td>EKG11412</td></tr>
                              <tr><td>  PL/I response block </td><td>None</td></tr>
                                <tr><td>PL/I usage coding </td><td>EKG51412</td></tr>
                               <tr><td> C function block </td><td>EKG31412</td></tr>
                               <tr><td> C response block</td><td> None</td></tr>
                            </table>
                            <i>Table 38. Example Names for the EKG_AddNotifySubscription Function (continued)</i>
<table border="2" cellpadding="7" cellspacing="7">
  <th>Example</th><th> Name</th>
<tr><td>C usage coding </td><td>EKG61412</td></tr>
</table>
<h4>Summary</h4>
<i>Table 39. Summary of the EKG_AddNotifySubscription Function</i>
<table border="2" cellpadding="7" cellspacing="7">
<th>Function</th><th> Setting</th>
<tr><td>Function ID</td><td> 1412</td></tr>
<tr><td>Type </td><td>Action</td></tr>
<tr><td>User API</td><td> Yes</td></tr>
<tr><td> Object-specific method </td><td>Yes </td></tr>
 <tr><td>Object-independent method </td><td>Yes</td></tr>
<tr><td>Initialization method </td><td>Yes</td></tr> 
<tr><td>Methods triggered </td><td>Notification method of MyObjectChildren
field of the EKG_NotificationQueue class
triggered if the notification queue object is created</td></tr>
<tr><td>Triggered by theEKG_MessageTriggeredAction function</td><td> No</td></tr>
<tr><td>Authorization </td><td>3</td></tr>
</table>
<p><h5>Usage</h5>
  See “RODM Notification Process” on page 323 for more information about<br>
  notification subscriptions.<br>
  A notification subscription, consisting of a User_appl_ID, Notification_queue,<br>
  method ObjectID, and Long_lived_parm is added to a field one time. If a second<br>
  request specifying the same information is sent, the request is rejected.<br>
  The class, object, and field access information from the function block specify<br>
  where the subscription is to be installed. If the value subfield of the designated<br>
  field is changed by the EKG_ChangeField or EKG_ChangeMultipleFields functions,<br>
  the requested notification method is run.<br>
  When a notification method is run, it is provided the value of the<br>
  Long_lived_parm field from the function block. The method cannot modify the<br>
  Long_lived_parm.<br>
  Users can assign notification subscriptions to both an object and its parent class<br>
  where both are run when a change is made to the object field. When these<br>
  notifications are added, RODM does not validate that duplicate subscriptions have<br>
  not been added between the class and object. Duplicate subscriptions are rejected<br>
  only at the individual class or object level.</p>
  <hr>
  <p><h3>EKG_AddObjDelSubs - Add Object Deletion Subscription<br>
    Purpose</h3>
    This function adds a deletion-subscription to an object; RODM sends you a<br>
    notification block if the object is deleted.<br>
    <h4>Function Block Format</h4>
   <i> Table 40. Function Block for the EKG_AddObjDelSubs Function</i></p><br>
   <img src="30.PNG">
   <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
    parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
    information about the abstract data types listed.</p><br>
    <p><b>Examples</b>
    <i>Table 41. Example Names for the EKG_AddObjDelSubs Function</i></p>
    <img src="31.PNG">
    <p><h5>Summary</h5>
      <i>Table 42. Summary of the EKG_AddObjDelSubs Function</i></p>
      <img src="32.PNG">
      <hr>
      <p><h5>Usage</h5>
        A deletion-notification subscription, consisting of a User_appl_ID,<br>
        Notification_queue, and Long_lived_parm, is added to an object one time. If a<br>
        second request specifying the same information is sent, the request is rejected.<br>
        The object access information from the function block specifies where the<br>
        subscription is to be installed. If the designated object is deleted by the<br>
        EKG_DeleteObject function, a notification block is sent to the user application. The<br>
        content of the notification block is the output from the EKG_QueryNotifyQueue<br>
        function. For more information, see “EKG_QueryNotifyQueue - Query Notification<br>
        Queue” on page 427.<br>
       <h3 >EKG_ChangeField - Change a Field<br>
        Purpose</h3>
        This function changes the value of a field of either an object or a class. This<br>
        function triggers any change or notification methods that are defined on the field.<br>
        <h5>Function Block Format</h5><br>
        <i>Table 43. Function Block for the EKG_ChangeField Function</i></p><br>
        <img src="33.PNG">
        <p>Note that the Subfield parameter at offset 012 is not currently used.<br>
          See “Function Parameter Descriptions” on page 452 for more information about the<br>
          parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
          information about the abstract data types listed.</p>
          <h4>Examples</h4><br>
          <i>Table 44. Example Names for the EKG_ChangeField Function</i><br>
          <img src="34.PNG">

          <b><summary></b><br>
            <i>Table 45. Summary of the EKG_ChangeField Function</i><br>
            <img src="35.PNG">
            <p><b>Usage</b>
              The new value pointed to by New_data_ptr must be of the same data type as the<br>
              target field being changed. The new value must be formatted correctly for that<br>
              data type. The Data_type field must specify the same data type as the target field.<br>
              You cannot use this function to change fields that have a data type of ObjectID,<br>
              ObjectIDList, ObjectLink, ObjectLinkList, ClassID, ClassIDList, or ClassLinkList.<br>
              These fields are set either by RODM, or by the LINK and UNLINK transactions.<br>
              You cannot use this function to change the RODM system-defined fields that have<br>
              read-only access, such as MyName and MyID.<br>
              Multiple field values can be changed using the EKG_ChangeMultipleFields<br>
              function.<br>
             <h3> EKG_ChangeMultipleFields - Change Multiple Fields<br>
              Purpose</h3>
              This function enables you to change the value of multiple fields of an object. This<br>
              function triggers change and notification methods that are defined on the field.<br>
              Function Block Format<br>
             <i>Table 46. Function Block for the EKG_ChangeMultipleFields Function</i></p><br>
             <img src="36.PNG">
             <hr>
             <p><i>Table 46. Function Block for the EKG_ChangeMultipleFields Function (continued)</i></p><br>
             <img src="37.PNG">
             <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
              parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
              information about the abstract data types listed.</p>
              <h4>Examples</h4>
               <i>Table 47. Example Names for the EKG_ChangeMultipleFields Function</i><br>
               <img src="38.PNG">
               <h4>Summary</h4>
               <i>Table 48. Summary of the EKG_ChangeMultipleFields Function</i><br>
               <img src="39.PNG">
               <p><b>Usage</b>
                The new value pointed to by New_data_ptr must be of the same data type as the<br>
                target field being changed. The new value must be formatted correctly for that<br>
                data type. The Data_type field must specify the same data type as the target field.<br>
                You cannot use this function to change fields that have a data type of ObjectID,<br>
                ObjectIDList, ObjectLink, ObjectLinkList, ClassID, ClassIDList, or ClassLinkList.<br>
                These fields are set either by RODM or by the LINK and UNLINK transactions.</p>
                <hr>
                <p>You cannot use this function to change the RODM system-defined fields that have<br>
                  read-only access, such as MyName and MyID.<br>
                <h4>  EKG_ChangeSubfield - Change a Subfield<br>
                  Purpose</h4>
                  This function enables you to change the value of a subfield without triggering<br>
                  change and notification methods.<br>
                <h4>  Function Block Format</h4>
                 <i> Table 49. Function Block for the EKG_ChangeSubfield Function</i></p><br>
                 <img src="40.PNG">
                 <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                  parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                  information about the abstract data types listed.<br>
                <b>Examples</b><br>
                <i>Table 50. Example Names for the EKG_ChangeSubfield Function</i></p><br>
                <img src="41.PNG">
                <p><b>Summary</b><br>
                <i>  Table 51. Summary of the EKG_ChangeSubfield Function</i></p>
                <img src="42.PNG">
                <hr>
                <p><i>Table 51. Summary of the EKG_ChangeSubfield Function (continued)</i></p>
                <img src="43.PNG">
                <p><b>Usage</b>
                  If the value subfield is to be changed, the data type of the new data must be<br>
                  identical with that of the field. For other subfields, the data type of the subfield is<br>
                  determined by the subfield type, and RODM checks that the data_type field in the<br>
                  function block is compatible with the specified subfield.<br>
                  The change of a value subfield does not cause the prev_val and timestamp<br>
                  subfields to be updated, nor does it run a change or notification method.<br>
                <h3> EKG_Checkpoint - Checkpoint RODM to DASD<br>
                  Purpose</h3>
                  This function causes RODM to write a copy of its in-storage data to a checkpoint<br>
                  data set. Use this checkpoint data set to recover RODM data after a system failure.<br>
                 <h4> Function Block Format</h4><br>
                  <i>Table 52. Function Block for the EKG_Checkpoint Function</i></p>
                  <img src="44.PNG">
                  <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                    parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                    information about the abstract data types listed.<br>
                  <b>Examples</b><br>
                  <i>Table 53. Example Names for the EKG_Checkpoint Function</i></p>
                  <img src="45.PNG">

                <p> <b>Summary</b></p>

                  <p><i> Table 54. Summary of the EKG_Checkpoint Function</i></p>

                   <img src="46.PNG">

                  <p> <i>Table 54. Summary of the EKG_Checkpoint Function (continued)</i><br></p>

                   <img src="47.PNG">

                   <p><b>Usage</b>
                    The EKG_Checkpoint function writes RODM data to predefined and preallocated<br>
                    VSAM linear data sets, which are called RODM checkpoint data sets.<br>
                    The checkpoint function is controlled using the CHECKPOINT_FUNCTION<br>
                    statement in member EKGCUST. Use this statement to either disable the<br>
                    checkpoint function or control how the checkpoint function reacts when a<br>
                    checkpoint failure occurs. See the IBM Tivoli NetView for z/OS Administration<br>
                    Reference for more information.<br>
                    The data that the EKG_Checkpoint function writes to the checkpoint data sets<br>
                    includes the following: <br>
                    <li> The RODM master window: a RODM data area that resides in the RODM<br>
                    address space and contains RODM system information. The RODM master<br>
                    window data is written to the master window checkpoint file.</li><br>
                    <li>RODM translation window: a RODM data area that resides in the RODM</li><br>
                    address space and contains the address information that enables correct data<br>
                    mapping and addressing in the RODM data cache. RODM translation window<br>
                    data is written to the translation window checkpoint file. <br>
                    <li> RODM data windows: RODM data areas that reside in data spaces and contain<br>
                    the actual data in the data cache. RODM data-window data is written to data<br>
                    window checkpoint files.</li><br>
                    The checkpoint process includes the following steps:<br>
                    1. Begin checkpoint: RODM sends a message to the console, notifying the<br>
                    operator that RODM is quiescing.<br>
                    2. Quiescing: during the checkpoint quiesce period, RODM allows method API<br>
                    requests, but rejects new user API requests. At the end of the quiesce period, if<br>
                    no user API, method API, or asynchronous transactions are still running,<br>
                    RODM proceeds to the next step in the checkpoint process, first stage<br>
                    checkpoint. Otherwise, RODM issues a Write-To-Operator with Reply (WTOR)<br>
                    message requesting directions from the operator. The operator must then select<br>
                    one of three options:<br>
                    <b>Option Meaning</b><br>
                    1 Perform the quiesce again. Choose this option if a checkpoint is really<br>
                    desired, but give RODM another quiesce period to successfully quiesce.</p>
                    <hr>
                    <p>2 Unconditionally, start first stage checkpoint. Choose this option if a<br>
                      checkpoint is immediately necessary or after having tried option one.<br>
                      3 Stop the checkpoint request. Choose this option if option one has been<br>
                      attempted or if critical RODM tasks must not be stopped.<br>
                      3. First stage checkpoint: after the quiescence time period ends and all<br>
                      transactions have finished processing or the operator has requested an<br>
                      unconditional checkpoint, RODM writes the master window and the translation<br>
                      windows to their respective checkpoint files.<br>
                      4. Second stage checkpoint: after the first stage checkpoint ends, RODM sends a<br>
                      message to the console notifying the operator that transactions can now<br>
                      resume. RODM then begins writing the data windows, one at a time, to the<br>
                      data window checkpoint files. User applications can make transaction requests<br>
                      during this checkpoint stage. However, a transaction will fail if the specific data<br>
                      window that it needs access to is being written to a data window checkpoint<br>
                      file or has not yet been written to a data window checkpoint file.<br>
                      5. End of checkpoint: after all data windows have been written to data window<br>
                      checkpoint files, RODM sends a message to the console notifying the operator<br>
                      that the checkpoint process has completed, and two EKG_System object fields<br>
                      are updated, depending on whether or not the checkpoint process was<br>
                      successful.<br>
                      The EKG_LastCheckpointID field of the EKG_System object is updated by<br>
                      RODM to reflect the transaction ID of the of the last checkpoint transaction if<br>
                      the checkpoint process is successful. Otherwise, the EKG_LastCheckpointID<br>
                      field remains unchanged.<br>
                      The EKG_LastCheckpointResult field of the EKG_System object is updated with<br>
                      the current transaction ID for a checkpoint process issued from a MODIFY<br>
                      command, or the transaction ID of the user API requesting the checkpoint<br>
                      process. The EKG_LastCheckpointResult field also reflects the result of the<br>
                      checkpoint process by use of return and reason codes. Application programs<br>
                      that are subscribed to this field receive notification that the checkpoint process<br>
                      has completed.<br>
                      With the exception of the checkpoint process, all transactions issued across the<br>
                      RODM user API are synchronous in that the user does not regain execution control<br>
                      until the transaction has completed. With the checkpoint process, the application<br>
                      regains control when the checkpoint request has been recorded. The checkpoint<br>
                      operation is actually processed asynchronously with other processing in the<br>
                      application. This same asynchronous processing for the checkpoint process also<br>
                      applies to an operator-requested checkpoint process, through the MODIFY<br>
                      command.<br>
                    <h4>Coding Checkpoint Control</h4><br>
                      RODM updates the EKG_LastCheckpointResult field in the EKG_System class each<br>
                      time RODM completes a checkpoint operation. The EKG_LastCheckpointResult<br>
                      field contains the transaction ID of the transaction requesting the checkpoint<br>
                      operation and the return and reason codes indicating the result of the checkpoint<br>
                      operation. Applications can subscribe to this field to be notified of the completion<br>
                      of each checkpoint operation.<br>
                      Subscribe to the EKG_LastCheckpointResult field to be notified of the result of the<br>
                      checkpoint. The user can then query the field and determine the result of the<br>
                      checkpoint operation. If the checkpoint operation is not successful, the user can<br>
                      then determine why the checkpoint process failed.</p>
                      <hr>
                      <p>A user application can keep a record or journal of its transactions with RODM. If<br>
                        RODM fails between checkpoint operations, the application can then determine<br>
                        which transactions have been checkpointed by RODM and which transactions have<br>
                        to be resent. All transactions in that journal numerically the same or lower than the<br>
                        EKG_LastCheckPointID field are reflected in the checkpoint data sets of the<br>
                        successfully completed checkpoint operations and can be erased from the journal.<br>
                        All transactions numerically higher than the EKG_LastCheckPointID field have to<br>
                        be reset to restore RODM to its status before the failure.<br>
                        From the beginning of a checkpoint operation until stage 1 is completed, RODM<br>
                        rejects any additional transaction requests and provides a return code and reason<br>
                        code identifying that condition if keyword TRANSPARENT_CHECKPOINT=NO is
                        specified in the customization file.<br>
                        User applications can subscribe to the EKG_LastCheckpointID field, the<br>
                        EKG_LastCheckpointResult field, or to both fields, using the<br>
                        EKG_AddNotifySubscription function. See “EKG_AddNotifySubscription - Add<br>
                        Notification Subscription” on page 377. You can use the EKGNOTF notification<br>
                        method that is supplied with the NetView program for this subscription. See<br>
                        “RODM Notification Methods” on page 489 for a description of EKGNOTF. <br>
                      <h4>  EKG_Connect - Connect to RODM Purpose</h4><br>
                        The connect function enables an application program to use RODM. This is the<br>
                        first function that the application can issue to RODM.<br>
                        Function Block Format<br>
                     <i>Table 55. Function Block for the EKG_Connect Function</i></p>
                     <img src="48.PNG">
                     <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                      parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                      information about the abstract data types listed.<br>
                    <b>Examples</b>
                     <i>Table 56. Example Names for the EKG_Connect Function</i></p>
                     <img src="49.PNG">
                     <hr>
                     <p><b>Summary</b>
                      <i>Table 57. Summary of the EKG_Connect Function</i></p>
                      <img src="50.PNG">
                      <p><b>Usage</b>
                        The User_appl_ID is used to determine the users access authority and to associate<br>
                        registered event control blocks (ECBs) with the appropriate user. <br>
                        If the system on which RODM is installed is protected by a system authorization<br>
                        facility, the user can connect to RODM using a blank user ID. RODM obtains the<br>
                        user ID from the system authorization facility and uses it to determine the user's<br>
                        access authority in RODM. If the system is not protected by a system authorization<br>
                        facility, the user cannot connect to RODM using a blank user ID.<br>
                        When a user application issues an EKG_Connect function request, RODM creates a<br>
                        user object from the EKG_User system-defined class.<br>
                        An access block, as described in “Access Block” on page 309, must be passed. The<br>
                        user's sign_on_token parameter in the access block is set by RODM. This<br>
                        parameter must not be changed by the user application for subsequent calls to<br>
                        RODM.<br>
                        A user can disconnect from RODM without purging the subscription notification<br>
                        queue. Before the notification queues that are owned by this user application ID<br>
                        can again be posted, all ECB addresses associated with all notification queues for<br>
                        this user and with subscription notifications must be reset for the new address<br>
                        space.<br>
                        All tasks in the address space from which the EKG_Connect function was issued<br>
                        can access RODM either by connecting to RODM with unique, RODM authorized<br>
                        user IDs, or by using the sign_on_token. The sign_on_token is not valid when the<br>
                        connecting TCB ends or the EKG_Disconnect function is performed.<br>
                      <h4> EKG_ConnectLong - Connect to RODM<br>
                        Purpose</h4>
                        The connectlong function enables an application program to use RODM. This is the<br>
                        first function the application can issue to RODM.</p>
                        <hr>
                        <img src="51.PNG">
                        <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                          parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                          information about the abstract data types listed.<br>
                         <b> Examples</b>
                        <i>  Table 59. Example Names for the EKG_ConnectLong Function</i></p>
                        <img src="52.PNG">
                        <p><b>Summary</b>
                         <i> Table 60. Summary of the EKG_ConnectLong Function</i></p>
                         <img src="53.PNG">
                         <p><b>Usage</b>
                          The User_appl_ID is used to determine the users access authority and to associate<br>
                          registered ECBs with the appropriate user. <br>
                          If the system on which RODM is installed is protected by a system authorization<br>
                          facility, the user can connect to RODM using a blank user ID. RODM obtains the</p>
                          <hr>
                          <p>user ID from the system authorization facility and uses it to determine the user's<br>
                            access authority in RODM. If the system is not protected by a system authorization<br>
                            facility, the user cannot connect to RODM using a blank user ID.<br>
                            When a user application issues an EKG_ConnectLong function request, RODM<br>
                            creates a user object from the EKG_User system-defined class.<br>
                            An access block, as described in “Access Block” on page 309, must be passed. The<br>
                            user's sign_on_token parameter in the access block is set by RODM. This<br>
                            parameter must not be changed by the user application for subsequent calls to<br>
                            RODM.<br>
                            A user can disconnect from RODM without purging the subscription notification<br>
                            queue. Before notification queues owned by this user application ID can again be<br>
                            posted, all ECB addresses associated with all notification queues for this user and<br>
                            with subscription notifications must be reset for the new address space.<br>
                            All tasks in the address space from which the EKG_ConnectLong function was<br>
                            issued can access RODM either by connecting to RODM with unique, RODM<br>
                            authorized user IDs, or by using the sign_on_token. The sign_on_token is not valid<br>
                            when the connecting TCB ends or the EKG_Disconnect function is performed.<br><br>
                            <h3>EKG_CreateClass - Create a Class<br>
                            Purpose</h3>
                            This function creates a new class as the child of a specified parent class in the<br>
                            RODM data cache. RODM adds the new class ID entry to the MyClassChildren<br>
                            linked-list field of the parent of the new class.<br>
                            Function Block Format<br>
                           <i> Table 61. Function Block for the EKG_CreateClass Function</i></p>
                           <img src="54.PNG">
                           <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                            parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                            information about the abstract data types listed.<br>
                          <b>Examples</b>
                          <i>Table 62. Example Names for the EKG_CreateClass Function</i></p>
                          <img src="55.PNG">
                          <hr>
                          <i>Table 62. Example Names for the EKG_CreateClass Function (continued)</i>
                          <table border="2" cellpadding="7" cellspacing="7">
                            <th>Example</th><th> Name</th>
                            <tr><td>C usage coding </td><td>EKG61302</td></tr>
                          </table>
                          <p><b>Summary</b>
                           <i> Table 63. Summary of the EKG_CreateClass Function</i></p>
                           <img src="56.PNG">
                           <p><b>Usage</b>
                            Specify the class name and RODM returns the associated ID.<br>
                            Classes are created only with system-defined fields and those fields that are<br>
                            inherited through the primary hierarchy. All additional fields must be added<br>
                            explicitly by calls to RODM.<br>
                            Creating a class changes the value of the WhatIAm field of the parent of the class<br>
                            if the parent did not have any class children.<br>
                           <h3> EKG_CreateField - Create a Field<br>
                            Purpose</h3><br>
                            This function creates a new field on a class in the RODM data cache.<br>
                            Function Block Format<br>
                            Table 64. Function Block for the EKG_CreateField Function</p>
                            <img src="57.PNG">
                            <hr>
                            <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                              parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                              information about the abstract data types listed.<br>
                             <b> Examples</b>
                              <i>Table 65. Example Names for the EKG_CreateField Function</i></p>
                              <img src="58.PNG">
                              <p><b>Summary</b>
                               <i> Table 66. Summary of the EKG_CreateField Function</i></p>
                               <img src="59.PNG">
                               <p><b>Usage</b>
                                The initial value for a field is the null value of the field's data type.<br>
                                When a field is created, RODM applies the following rules:<br>
                                 <li> If the field being added to a class is public and has the same name and fields</li><br>
                                (that is, data type and subfield definitions) as a public field already defined in a<br>
                                subclass, the field is defined in the specified class and the subclass defined field<br>
                                is treated as a local value for that field (this affects what value is inherited below<br>
                                the subclass). If the data type of the field in the subclass is different from the<br>
                                new data type, the new definition is rejected. <br>
                                <li>If the new field being added is a private field, no check is made for subclass<br>
                                definitions.</li><br>
                                <li>If a new field definition is for a public field and there is an existing private</li><br>
                                definition in a subclass of the specified class, the new field definition is rejected.</p>
                                <hr>
                                <p>If the field already exists and has exactly the same data type and subfield<br>
                                  definitions as was requested, a warning return code is generated and a reason code<br>
                                  describing that condition is returned. The original field is left as previously<br>
                                  defined.<br>
                                  If a subfield that is not valid is specified, RODM does not create that subfield.<br>
                                  However, RODM does create the field and all valid requested subfields. RODM<br>
                                  issues the warning return code 4 with reason code 100.<br>
                                 <h3> EKG_CreateObject - Create an Object<br>
                                  Purpose</h3><br>
                                  This function creates a new object in the RODM data cache. RODM adds the new<br>
                                  object ID entry to the MyObjectChildren linked-list field of the parent of the new<br>
                                  object.<br>
                                 <h4>Function Block Format</h4><br>
                                  Table 67. Function Block for the EKG_CreateObject Function</p>
                                  <img src="60.PNG">
                                  <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
                                    parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
                                    information about the abstract data types listed.<br>
                                  <b>  Examples</b>
                                  <i>Table 68. Example Names for the EKG_CreateObject Function</i></p>
                                  <img src="61.PNG">
                                  <p><b>Summary</b>
                                  <i> Table 69. Summary of the EKG_CreateObject Function</i></p>
                                  <img src="62.PNG">
                                  <hr>
                                  <img src="63.PNG">
                                  <p>Usage
                                    The Entity_access_info_ptr must point to an entity access block that specifies the<br>
                                    class which is the parent of the object being created. The Object_name_ptr of the<br>
                                    entity access block is optional. If the Object_name_ptr is specified, it must point to<br>
                                    a field of type ObjectName that contains the name of the requested new object.<br>
                                    Otherwise, RODM assigns the new object a name.<br>
                                    If you are creating an object of the EKG_Method class or the<br>
                                    EKG_NotificationQueue class, the object name is required. Object names for these<br>
                                    classes are limited to 8 characters.<br>
                                    The object name is not returned to the caller through this interface, but can be<br>
                                    accessed by querying the MyName field of the object. RODM assigns names in the<br>
                                    form EKGddddddd where ddddddd is a decimal number from 0000000 to 9999999. If<br>
                                    you specify the object name, do not specify an object name that begins with EKG.<br>
                                    The Object_ID field in the entity access block is set by RODM when the object is<br>
                                    successfully created. The Method_Parms short_lived_parameters are passed to the<br>
                                    notification method on the MyObjectChildren field of the class and the notification<br>
                                    method, if one exists, is triggered.<br>
                                    When a new object is created, it contains all of the public locally- defined and<br>
                                    inherited fields that appear on the class of the new object. The values in these<br>
                                    fields are initially the default values inherited from the class except for the<br>
                                    system-defined fields, which are set by RODM, and fields of type ObjectLink,<br>
                                    which are empty fields.<br>
                                    All subfields, wherever they exist, begin existence on a new object with inherited<br>
                                    values except for the notify subfield. A Notify subfield starts out with the null<br>
                                    value.<br>
                                    If the parent class does not have any object children when this object is created,<br>
                                    RODM updates the WhatIAm field of the class to indicate that the class now has<br>
                                    object children.<br>
                                  <h3>  EKG_CreateSubfield - Create a Subfield<br>
                                    Purpose</h3><br>
                                    This function creates one or more subfields for an existing field in an existing class<br>
                                    in the RODM data cache.</p>
                                    <hr>
                                    <img src="64.PNG">
                                 <p>   See “Function Parameter Descriptions” on page 452 for more information about the<br>
parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
information about the abstract data types listed.<br>
<b>Examples</b>
<i>Table 71. Example Names for the EKG_CreateSubfield Function</i></p>
<img src="65.PNG">
<p><b>Summary</b>
<i>Table 72. Summary of the EKG_CreateSubfield Function</i><br></p>
<img src="66.PNG">
<p><b>Usage</b>
  Subfields can be created only on an existing field of a class. Subfields must be<br>
  created in the class in which the field was created.<br>
  If a specified subfield already exists and other specified subfields do not exist, the<br>
  subfields that do not exist are created and a warning return code is generated</p>
  <hr>
  <p><h3>EKG_DeleteClass - Delete a Class<br>
    Purpose</h3>
    This function deletes an existing class from the RODM data cache. RODM removes<br>
    the value in the MyID field of the deleted class from the MyClassChildren<br>
    linked-list field of the parent of the deleted class.<br>
   <h4> Function Block Format</h4>
    Table 73. Function Block for the EKG_DeleteClass Function</p>
    <img src="67.PNG">
    <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
      parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
      information about the abstract data types listed.<br>
     <b> Examples</b>
      <i>Table 74. Example Names for the EKG_DeleteClass Function</i></p>
      <p><b>Summary</b>
       <i> Table 75. Summary of the EKG_DeleteClass Function</i></p>
       <img src="68.PNG">
       <hr>
       <p><b>Usage</b>
        You cannot delete a RODM system-defined class or a class that has children.<br>
        Deleting a class will change the value of the WhatIAm field of the parent of the<br>
        class if the parent class no longer has any class children.<br>
      <h3>  EKG_DeleteField - Delete a Field<br>
        Purpose</h3><br>
        This function deletes a field from a class in the RODM data cache. The field is also<br>
        deleted from any classes and objects that inherit the field from this class.<br>
        Function Block Format<br>
      <i>  Table 76. Function Block for the EKG_DeleteField Function</i></p>
      <img src="69.PNG">
      <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
        parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
        information about the abstract data types listed.<br>
       <b> Examples</b>
      <i> Table 77. Example Names for the EKG_DeleteField Function</i></p>
      <img src="70.PNG">
      <p><b>Summary</b>
       <i> Table 78. Summary of the EKG_DeleteField Function</i></p>
       <img src="71.PNG">
       <hr>
       <img src="72.PNG">
       <p><b>Usage</b>
        Fields can be deleted only from classes; they cannot be deleted from objects.<br>
        Deletion of a public field on a class removes the existence of that field from all<br>
        descendant classes.<br>
        Before a public field can be deleted from a class, you must delete all objects<br>
        created from that class and from descendent classes of that class.<br>
        Local values assigned to a field are discarded when that field is deleted.<br>
        Private fields can be deleted at any time.<br>
       <h3> EKG_DeleteNotifySubscription - Delete Notification<br>
        Subscription</h3><br>
      <h4>  Purpose</h4><br>
        This function deletes one or more notification subscriptions from a field.<br>
        <b>Function Block Format</b><br>
        Table 79. Function Block for the EKG_DeleteNotifySubscription Function</p>
        <img src="73.PNG">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
          parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
          information about the abstract data types listed.<br>
          <b>Examples</b>
         <i> Table 80. Example Names for the EKG_DeleteNotifySubscription Function</i></p>
         <img src="74.PNG">
         <hr>
         <img src="75.PNG">
         <p><b>Summary</b>
        <i>  Table 81. Summary of the EKG_DeleteNotifySubscription Function</i></p>
        <img src="76.PNG">
        <p><b>Usage</b>
          Deleting a notification subscription does not delete the notification blocks that are<br>
          queued on the notification queue when the delete function is issued. The<br>
          notification queue object is not deleted.<br>
          The notification subscription that is to be deleted is uniquely identified by four<br>
          fields: the User_appl_ID field, the Notification_queue field, the Notify_method<br>
          field, and the Long_lived_parm field. Using these four fields, the<br>
          EKG_DeleteNotifySubscription function deletes one or more notification<br>
          subscriptions based on the first of the following rules that applies:<br>
          1. If the Notification_queue field is set to an asterisk followed by seven blanks<br>
          ("* "), and the Notify_method and Long_lived_parm fields are set to<br>
          null values, all subscriptions associated with the specified User_appl_ID field<br>
          are deleted.<br>
          2. If the Notification_queue field is set to an asterisk followed by seven blanks<br>
          ("* "), all subscriptions associated with the specified User_appl_ID,<br>
          Notify_method, and Long_lived_parm fields are deleted.<br>
          3. If the Notify_method field is set to the null value, RODM deletes the<br>
          notification subscriptions that meet the other criteria without considering the<br>
          value in the Notify_method field.<br>
          4. If the Long_lived_parm field is set to the null value, RODM deletes the<br>
          notification subscriptions that meet the other criteria without considering the<br>
          value in the Long_lived_parm field.<br>
          Specifying User_appl_ID as a null value does not have the same effect as<br>
          specifying null values for the other parameters. A Null User_appl_ID value is<br>
          interpreted the same here as for the EKG_AddNotifySubscription function; it</p>
          <hr>
          <p>requires RODM to supply a default value. The default is determined exactly as for<br>
            the EKG_AddNotifySubscription function (see “EKG_AddNotifySubscription - Add<br>
            Notification Subscription” on page 377).<br>
            To specify a null Long_lived_parm, declare a pointer to the Long_lived_parm data<br>
            type with a value of zero.<br>
         <h3>   EKG_DeleteObject - Delete an Object<br>
            Purpose</h3><br>
            This function deletes an existing object from a specified class. RODM deletes the<br>
            object ID of the deleted object from the MyObjectChildren field of the parent class<br>
            of the deleted object.<br>
            <b>Function Block Format</b><br>
            Table 82. Function Block for the EKG_DeleteObject Function</p>
            <img src="77.PNG">
            <p>See “Function Parameter Descriptions” on page 452 for more information about the<br>
              parameters listed. See “Abstract Data Type Reference” on page 219 for more<br>
              information about the abstract data types listed.<br>
             <b> Examples</b>
             <i> Table 83. Example Names for the EKG_DeleteObject Function</i></p>
             <img src="78.PNG">
             <p><b>Summary</b>
             <i> Table 84. Summary of the EKG_DeleteObject Function</i></p>
             <img src="79.PNG">
 </body>
                                                            <style>
                                                                body{
                                                                    padding-left: 30%;
                                                                }
                                                                hr{
    background:black;
    height:2px;
    position: relative;
    border: none;
}
table{
    font-size: small;
}
                                                            </style>
                                                            </html>
                                                        